					<article>
		<h2>Building a TCP Proxy</h2>
		<h6>There are a number of reasons to have a TCP proxy in your tool belt, both for forwarding traffic to
bounce from host to host, but also when assessing network-based software. When performing penetration tests in enterprise environments, you'll commonly be faced with the fact that you can't run Wireshark, that you can't load drivers to sniff the loopback on Windows, or that network segmentation prevents you from running your tools directly against your target host. I have employed a simple Python proxy in a number of cases to help understand unknown protocols, modify traffic being sent to an application, and create test cases for fuzzers. Let's get to it.</h6>
	<p></p>
	<pre style="background-color:#111; color:white; margin: 50px 0px 50px;border: 5px solid darkgray; 
border-radius: 1%; ">


	import sys	
	import socket
	import threading

	def server_loop(local_host,local_port,remote_host,remote_port,receive_first):

		<span style="text-decoration: underline;">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span>

		try:

			<span style="text-decoration: underline;">server.bind((local_host, local_port))</span>

		except:

			<span style="color:yellow">print "[!!] Failed to listen on %s:%d" % (local_host,local_port)</span>
			<span style="color:yellow">print "[!!] Check for other listening sockets or correct permissions."</span>
			sys.exit(0)
			<span style="color:yellow">print "[*] Listening on %s:%d" % (local_host,local_port)</span>
			<span style="text-decoration: underline;">server.listen(5)</span>

		while True:

		            <span style="text-decoration: underline;">client_socket, addr = server.accept()</span>

		            <span style="color:crimson"># print out the local connection information</span>
		            <span style="color:yellow">print "[==>] Received incoming connection from %s:%d" % (addr[0],addr[1])</span>
		            <span style="color:crimson"># start a thread to talk to the remote host</span>
		            proxy_thread = threading.Thread(target=proxy_handler, args=(
		            client_socket,remote_host,remote_port,receive_first))
		            proxy_thread.start

     def main():

     	<span style="color:crimson">#no fancy command-line parsing here</span>
     	if len(sys.argv[1:]) !0 5:

     		<span style="color:yellow">print "Usage: ./proxy.py [localhost] [localport] [remotehost] [remoteport] [receive_first]"</span>
 			<span style="color:yellow">print "Example: ./proxy.py 127.0.0.1 9000 10.12.132.1 9000 True"</span>
 			sys.exit(0)

 		<span style="color:crimson">setup local listening parameters</span>
 		local_host = sys.argv[1]
 		local_port = int(sys.agrv[2])


 		<span style="color:crimson"># setup remote target</span>
    	remote_host = sys.argv[3]
    	remote_port = int(sys.argv[4])

    	<span style="color:crimson"># this tells our proxy to connect and receive data</span>
    	<span style="color:crimson"># before sending to the remote host</span>
    	receive_first = sys.argv[5]

    	if "True" in receive_first:
    		receive_first = True
    	else:
    		receive_first = False

    	<span style="color:crimson">#now spin up our listening socket</span>
    	server_loop(local_host, local_port, remove_host, remote_port, receive_first)

    	#Call main
    	main()

    	</pre>

    	<h6>Most of this should look familiar: we take in some command-line arguments and then fire up a server loop that listens for connections. When a fresh connection request comes in, we hand it off to our <span style="text-decoration: underline;">proxy_handler, which does all of the sending and receiving of juicy bits to either side of the data stream.</span> Let's dive into the proxy_handler function now by adding the following code above our main function.</h6>

    	<pre style="background-color:#111; color:white; margin: 50px 0px 50px; border: 5px solid darkgray;
border-radius: 1%;" >
		


		def	proxy_handler(client_socket, remote_host, remote_port, receive_fist):	

		<span style="color:crimson">#connect to the remote host</span>
		<span style="text-decoration: underline;">remote_socket = socket.socket(socket.AF_INET, socket.SOCK_STEAM)</span>
		<span style="text-decoration: underline;">remote_socket.connect((remote_host, remote_port))</span>

		<span style="color:crimson">#receive data from the remote end if necessary</span>
<span style="font-size: 30px; color:white;">(1)</span>		if receive_first:

<span style="font-size: 30px; color:white;">(2)</span>			remove_buffer = <span style="text-decoration: underline;">receive_from(remote_socket)</span>
<span style="font-size: 30px; color:white;">(3)</span>			hexdump(remote_buffer)

			<span style="color:crimson">#send it to our reponse handler</span>
<span style="font-size: 30px; color:white;">(4)</span>			remote_buffer = response_handler(remove_buffer)

			<span style="color:crimson">#if we have data to send to our local client, send it</span>
			if len(remove_buffer):
			<span style="color:yellow">print "[<==] Sending %d bytes to localhost." % len(remote_buffer)</span>	
			client_socket.send(remote_buffer)
		<span style="color:crimson">#now lets loop and read from local, send to remote, send to local</span>
		<span style="color:crimson">#rinse, wash, repeat</span>
		while True:

			<span style="color:crimson">#read from localhost</span>
			local_buffer = <span style="text-decoration: underline;">receive_from(client_socket)</span>

			if len(local_buffer):

				<span style="color: yellow">print "[==>] Received %d bytes from localhost." % len(local_buffer"</span>
				hexdump(local_buffer)

				<span style="color:crimson">#send it to our request handler</span>
				local_buffer = request_handler(local_buffer)

				<span style="color:crimson">send off the data to the remote host</span>
				remote_socket.<span style="text-decoration: underline;">send(local_buffer)</span>
				<span style="color: yellow">print "[==>] Sent to remote."</span>

				<span style="color:crimson">#receive back the response</span>

			if len(remote_buffer):

				<span style="color:yellow">print "[<==] Received %d bytes from remote." % len(remote_buffer)</span>
				hexdump(remote_buffer)

				<span style="color:crimson">#send to our response handler</span>
				remote_buffer = response_handler(remote_buffer)

				<span style="color:crimson">#send the response to the local socket</span>
				client_socket.send(remote_buffer)

				<span style="color:yellow">print "[<==] Sent to localhost."</span>

				<span style="color: crimson"># if no more data on either side, close the connections</span>
<span style="font-size: 30px; color:white;">(5)</span>				if not len(local_buffer) or not len(remote_buffer):
					client_socket.close()
					remote_socket.close()
					<span style="color: yellow">print "[*] No more data. Closing connections."</span>
					break


    	</pre> 
    	<h6>This function contains the bulk of the logic for our proxy. To start off, we check to make sure we don't need to first initiate a connection to the remote side and request data before going into our main loop <b>(1)</b>. Some server daemons will expect you to do this first (FTP servers typically send a banner first, for example). We then use our receive_from function <b>(2)</b>, which we reuse for both sides of the communication; it simply takes in a connected socket object and performs a receive. We then dump the contents <b>(3)</b> of the packet so that we can inspect it for anything interesting. Next we hand the output to our response_handler function <b>(4)</b>. Inside this function, you can modify the packet contents, perform fuzzing tasks, test for authentication issues, or whatever else your heart desires. There is a complimentary request_handler function that does the same for modifying outbound traffic as well. The final step is to send the received buffer to our local client. The rest of the proxy code is straightforward: we continually read from local, process, send to remote, read from remote, process, and send to local until there is no more data detected <b>(5)</b>. Let's put together the rest of our functions to complete our proxy.</h6>

    	<pre style="background-color:#111; color:white; margin: 50px 0px 50px; border: 5px solid darkgray;
border-radius: 1%;" >
    	

<span style="font-size: 30px; color:white;">(1)</span>    	def hexdump(src, length=16):

    		results = []
    		digits = 4 if isinstance(src, unicode) else 2
    		<span style="color: crimson">#our for loop with three parameters (start, stop, step) starts at 0,
    		#stops at the len(src) and steps length times</span>
    		for i in xrange(0, len(src), length):
    			s = src[i:i+length]
    			hexa = b' '.join(["0%*X" % (digits, ord(x)) for x in s])
    			text = b''.join([x if 0x20 <= ord(x) < 0x7F else b'.' for x in s])
    			result.append( b"%04X %-*s %s" % (o, length*(digits +1), hexa, text))

    		<span style="color:yellow">print b'\n'.join(result)</span>


<span style="font-size: 30px; color:white;">(2)</span>		def receive_from(connection):
			buffer = ""

			<span style="color: crimson">#We set a 2 second timeout; depending on your target</span>
			<span style="color: crimson">#this may need to be adjusted</span>
			connection.settimeout(2)

				try:
					#keep reading into the buffer until there's not more data
					#or we timeout
					while True:

						data = connection.recv(4096)

						if not data:
							break
						buffer += data

				except:
				pass

				return buffer


		<span style="color: crimson">#modify any requests destined for the remote host</span>
<span style="font-size: 30px; color:white;">(3)</span>		def request_handler(buffer):
			<span style="color: crimson">#perform packet modifications</span>
			return buffer

		<span style="color: crimson">#modify any responses destined for the local host</span>
		def response_handler(buffer):
			<span style="color: crimson">#perform packet modifications</span>
			return buffer

    	</pre>

    	<h6>This is the final chunk of code to complete our proxy. First we create our hex dumping function <b>(1)</b> that will simply <u>output the packet details with both their hexadecimal values and ASCII-printable characters.</u> This is useful for understanding unknown protocols, finding user credentials in plaintext protocols, and much more. The receive_from function <b>(2)</b> is used both for <u>receiving local and remote data, and we simply pass in the socket object to be used.</u> By default, there is a two-second timeout set, which might be aggressive if you are proxying traffic to other countries or over lossy networks (increase the timeout as necessary). The rest of the function simply <u>handles receiving data until more data is detected on the other end of the connection</u>. Our last two functions <b>(3)</b> <b>(4)</b> <u>enable you to modify any traffic that is destined for either end of the proxy.</u> This can be useful, for example, if plaintext user credentials are being sent and you want to try to elevate privileges on an application by passing in admin instead of justin . Now that we have our proxy set up, let's take it for a spin.</h6>


    	<p>Black Hat python</p>

<h3>All together</h3>
<pre style="background-color:#111; color:white; margin: 50px 0px 50px; border: 5px solid darkgray;
">



import sys	
import socket
import threading

def server_loop(local_host,local_port,remote_host,remote_port,receive_first):

	server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

	try:

		server.bind((local_host, local_port))

	except:

		print "[!!] Failed to listen on %s:%d" % (local_host,local_port)
		print "[!!] Check for other listening sockets or correct permissions."
		sys.exit(0)

	print "[*] Listening on %s:%d" % (local_host,local_port)
	server.listen(5)
	while True:

		client_socket, addr = server.accept()

		# print out the local connection information
		print "[==>] Received incoming connection from %s:%d" % (addr[0],addr[1])
		# start a thread to talk to the remote host
		proxy_thread = threading.Thread(target=proxy_handler, args=(client_socket,remote_host,remote_port,receive_first))
		proxy_thread.start()

def	proxy_handler(client_socket, remote_host, remote_port, receive_fist):

	#connect to the remote host
	remote_socket = socket.socket(socket.AF_INET, socket.SOCK_STEAM)
	remote_socket.connect((remote_host, remote_port))

	#receive data from the remote end if necessary
	if receive_first:

		remote_buffer = receive_from(remote_socket)
		hexdump(remote_buffer)

		#send it to our reponse handler
		remote_buffer = response_handler(remote_buffer)

		#if we have data to send to our local client, send it
	if len(remote_buffer):
		print "[<==] Sending %d bytes to localhost." % len(remote_buffer)	
		client_socket.send(remote_buffer)
		#now lets loop and read from local, send to remote, send to local
		#rinse, wash, repeat
		while True:

			#read from localhost
			local_buffer = receive_from(client_socket)

			if len(local_buffer):

				print "[==>] Received %d bytes from localhost." % len(local_buffer)
				hexdump(local_buffer)

				#send it to our request handler
				local_buffer = request_handler(local_buffer)

				#send off the data to the remote host
				remote_socket.send(local_buffer)
				print "[==>] Sent to remote."

				#receive back the response

			if len(remote_buffer):

				print "[<==] Received %d bytes from remote." % len(remote_buffer)
				hexdump(remote_buffer)

				#send to our response handler
				remote_buffer = response_handler(remote_buffer)

				#send the response to the local socket
				client_socket.send(remote_buffer)

				print "[<==] Sent to localhost."

			# if no more data on either side, close the connections
			if not len(local_buffer) or not len(remote_buffer):
				client_socket.close()
				remote_socket.close()
				print "[*] No more data. Closing connections."
				break

def hexdump(src, length=16):

	results = []
	digits = 4 if isinstance(src, unicode) else 2
	#our for loop with three parameters (start, stop, step) starts at 0,
	#stops at the len(src) and steps length times
	for i in xrange(0, len(src), length):
		s = src[i:i+length]
		hexa = b' '.join(["0%*X" % (digits, ord(x)) for x in s])
		text = b' '.join([x if 0x20 <= ord(x) < 0x7F else b'.' for x in s])
		result.append( b"%04X %-*s %s" % (i, length*(digits +1), hexa, text))

	print b'\n'.join(result)

def receive_from(connection):
	buffer = ""

	#We set a 2 second timeout; depending on your target
	#this may need to be adjusted
	connection.settimeout(2)

	try:
		#keep reading into the buffer until there's not more data
		#or we timeout
		while True:

			data = connection.recv(4096)

			if not data:
				break

			buffer += data

	except:
		pass

	return buffer

#modify any requests destined for the remote host
def request_handler(buffer):
	#perform packet modifications
	return buffer

#modify any responses destined for the local host
def response_handler(buffer):
	#perform packet modifications
	return buffer



def main():

	#no fancy command-line parsing here
	if len(sys.argv[1:]) != 5:

		print "Usage: ./proxy.py [localhost] [localport] [remotehost] [remoteport] [receive_first]"
		print "Example: ./proxy.py 127.0.0.1 9000 10.12.132.1 9000 True"
		sys.exit(0)

	#setup local listening parameters
	local_host = sys.argv[1]
	local_port = int(sys.argv[2])


	# setup remote target
	remote_host = sys.argv[3]
	remote_port = int(sys.argv[4])

	# this tells our proxy to connect and receive data
	# before sending to the remote host
	receive_first = sys.argv[5]

	if "True" in receive_first:
		receive_first = True
	else:
		receive_first = False

	#now spin up our listening socket
	server_loop(local_host, local_port, remote_host, remote_port, receive_first)

main()






</pre>
		<img src="">
		

		</article>



		          <h2>Changing groups</h2>
          <p>first we check the groups using $groups</p>
          <img src="https://kctjdw.bn1301.livefilestore.com/y3mX7DKHnWhbT2cndPZtX1AM8K_jSJxXGjPBS--FBc4WDT2FVbE0K333RjXYb_8WAeuZt8xSfaCC15IkTt1oJK-acl2m2wEgeQRzR_acTJ5bpX8S5lGsMP1T3LjhZUaSBNta1C-6o8-tr0rWQYbWmWNVbpJlqvnydiECTyCIo0XfXg?width=656&height=30&cropmode=none">
          <p>sudo chown -R username:group directory</p>
          <p>Let's check out chown with $man chown</p>
          <p>we can see what the arg -R stands for:</p>
          <img src="https://kcrwkq.bn1301.livefilestore.com/y3mcvzDmvJUA_-M0doRjVtzb71-AAgaU8szMLYwtGs3QoBcqHRBV2_lWWvmmE7iqrDLwHAGx8nH_f2cUjDwmOGR2nEkRwVtw5pTPMV_qyxVRaQh8-VhaxZrXb_RX5350G3GY2KOKgNuxu1Il3OWlRT7MIufpbTHfSxjUOLXZG2Zn30?width=655&height=22&cropmode=none" >
          <p>And if we look at the bottom, cool it has some examples:</p>
          <img src="https://kctxbq.bn1301.livefilestore.com/y3m8QPXHO0ODpxnGLUWAJALkrrTj1tdvuRK0pzEi0nLGKWzW92OxnHsvFbh2gp1-0mG9Pd5FgoEjB6tjCL-4EMZ_t9aCl0XhN7V_dTd4CVn4CLJ70JAHuvrOlUbcoSiPeDgYtct_iAm4Gv9-EbzG0RdRhu3GscG5E4cdqfZYVXSVk4?width=653&height=74&cropmode=none" >
          <p>So now let's change our squid file permitions and group.</p>
          <img src="https://kcqgqa.bn1301.livefilestore.com/y3mHectkeg27pIWhtCxdnMwSXUhi887tE2AkhfF7lDU62u5ThDiAAyI1paqD44DSlyc6Pon0dNyTmVjmBIG21dJMhqTc3q4uZc7B80pI6Wtbd5DO23dw1O4iErkKSF3yR791NV7mSBxwOLZd2P9wM44M2bwT90uYDdPkmxOnBVbXFM?width=655&height=62&cropmode=none" >
          <p>Obviously we need root permissions to do so.</p>
          <p>Now if we check ours files again we can see that the owner and the group changed.</p>
          <img src="https://k5ks1g.bn1301.livefilestore.com/y3mRtID8qiuzIpjkav-ekCtJwxY_-J1SRShuLKZKVRRPAicj2c322W0M55DHfRMqfvyhuyicHyJEmP-0bgohfNCnsYqjriANkAjUmswRRDjtOVSARePR9hOeBH1yH24PDHjP37BTbq08mqWoSBMU4HZFwn58MnYi1HskXE1eon_Ghc?width=655&height=160&cropmode=none" >