					<article>
		<h2>Building a TCP Proxy</h2>
		<h6>There are a number of reasons to have a TCP proxy in your tool belt, both for forwarding traffic to
bounce from host to host, but also when assessing network-based software. When performing penetration tests in enterprise environments, you'll commonly be faced with the fact that you can't run Wireshark, that you can't load drivers to sniff the loopback on Windows, or that network segmentation prevents you from running your tools directly against your target host. I have employed a simple Python proxy in a number of cases to help understand unknown protocols, modify traffic being sent to an application, and create test cases for fuzzers. Let's get to it.</h6>
	<p></p>
	<pre style="background-color:#111; color:white; margin: 50px 0px 50px;border: 5px solid darkgray;
border-radius: 1%; ">


	import sys
	import socket
	import threading

	def server_loop(local_host,local_port,remote_host,remote_port,receive_first):

		<span style="text-decoration: underline;">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span>

		try:

			<span style="text-decoration: underline;">server.bind((local_host, local_port))</span>

		except:

			<span style="color:yellow">print "[!!] Failed to listen on %s:%d" % (local_host,local_port)</span>
			<span style="color:yellow">print "[!!] Check for other listening sockets or correct permissions."</span>
			sys.exit(0)
			<span style="color:yellow">print "[*] Listening on %s:%d" % (local_host,local_port)</span>
			<span style="text-decoration: underline;">server.listen(5)</span>

		while True:

		            <span style="text-decoration: underline;">client_socket, addr = server.accept()</span>

		            <span style="color:crimson"># print out the local connection information</span>
		            <span style="color:yellow">print "[==>] Received incoming connection from %s:%d" % (addr[0],addr[1])</span>
		            <span style="color:crimson"># start a thread to talk to the remote host</span>
		            proxy_thread = threading.Thread(target=proxy_handler, args=(
		            client_socket,remote_host,remote_port,receive_first))
		            proxy_thread.start

     def main():

     	<span style="color:crimson">#no fancy command-line parsing here</span>
     	if len(sys.argv[1:]) !0 5:

     		<span style="color:yellow">print "Usage: ./proxy.py [localhost] [localport] [remotehost] [remoteport] [receive_first]"</span>
 			<span style="color:yellow">print "Example: ./proxy.py 127.0.0.1 9000 10.12.132.1 9000 True"</span>
 			sys.exit(0)

 		<span style="color:crimson">setup local listening parameters</span>
 		local_host = sys.argv[1]
 		local_port = int(sys.agrv[2])


 		<span style="color:crimson"># setup remote target</span>
    	remote_host = sys.argv[3]
    	remote_port = int(sys.argv[4])

    	<span style="color:crimson"># this tells our proxy to connect and receive data</span>
    	<span style="color:crimson"># before sending to the remote host</span>
    	receive_first = sys.argv[5]

    	if "True" in receive_first:
    		receive_first = True
    	else:
    		receive_first = False

    	<span style="color:crimson">#now spin up our listening socket</span>
    	server_loop(local_host, local_port, remove_host, remote_port, receive_first)

    	#Call main
    	main()

    	</pre>

    	<h6>Most of this should look familiar: we take in some command-line arguments and then fire up a server loop that listens for connections. When a fresh connection request comes in, we hand it off to our <span style="text-decoration: underline;">proxy_handler, which does all of the sending and receiving of juicy bits to either side of the data stream.</span> Let's dive into the proxy_handler function now by adding the following code above our main function.</h6>

    	<pre style="background-color:#111; color:white; margin: 50px 0px 50px; border: 5px solid darkgray;
border-radius: 1%;" >



		def	proxy_handler(client_socket, remote_host, remote_port, receive_fist):

		<span style="color:crimson">#connect to the remote host</span>
		<span style="text-decoration: underline;">remote_socket = socket.socket(socket.AF_INET, socket.SOCK_STEAM)</span>
		<span style="text-decoration: underline;">remote_socket.connect((remote_host, remote_port))</span>

		<span style="color:crimson">#receive data from the remote end if necessary</span>
<span style="font-size: 30px; color:white;">(1)</span>		if receive_first:

<span style="font-size: 30px; color:white;">(2)</span>			remove_buffer = <span style="text-decoration: underline;">receive_from(remote_socket)</span>
<span style="font-size: 30px; color:white;">(3)</span>			hexdump(remote_buffer)

			<span style="color:crimson">#send it to our reponse handler</span>
<span style="font-size: 30px; color:white;">(4)</span>			remote_buffer = response_handler(remove_buffer)

			<span style="color:crimson">#if we have data to send to our local client, send it</span>
			if len(remove_buffer):
			<span style="color:yellow">print "[<==] Sending %d bytes to localhost." % len(remote_buffer)</span>
			client_socket.send(remote_buffer)
		<span style="color:crimson">#now lets loop and read from local, send to remote, send to local</span>
		<span style="color:crimson">#rinse, wash, repeat</span>
		while True:

			<span style="color:crimson">#read from localhost</span>
			local_buffer = <span style="text-decoration: underline;">receive_from(client_socket)</span>

			if len(local_buffer):

				<span style="color: yellow">print "[==>] Received %d bytes from localhost." % len(local_buffer"</span>
				hexdump(local_buffer)

				<span style="color:crimson">#send it to our request handler</span>
				local_buffer = request_handler(local_buffer)

				<span style="color:crimson">send off the data to the remote host</span>
				remote_socket.<span style="text-decoration: underline;">send(local_buffer)</span>
				<span style="color: yellow">print "[==>] Sent to remote."</span>

				<span style="color:crimson">#receive back the response</span>

			if len(remote_buffer):

				<span style="color:yellow">print "[<==] Received %d bytes from remote." % len(remote_buffer)</span>
				hexdump(remote_buffer)

				<span style="color:crimson">#send to our response handler</span>
				remote_buffer = response_handler(remote_buffer)

				<span style="color:crimson">#send the response to the local socket</span>
				client_socket.send(remote_buffer)

				<span style="color:yellow">print "[<==] Sent to localhost."</span>

				<span style="color: crimson"># if no more data on either side, close the connections</span>
<span style="font-size: 30px; color:white;">(5)</span>				if not len(local_buffer) or not len(remote_buffer):
					client_socket.close()
					remote_socket.close()
					<span style="color: yellow">print "[*] No more data. Closing connections."</span>
					break


    	</pre>
    	<h6>This function contains the bulk of the logic for our proxy. To start off, we check to make sure we don't need to first initiate a connection to the remote side and request data before going into our main loop <b>(1)</b>. Some server daemons will expect you to do this first (FTP servers typically send a banner first, for example). We then use our receive_from function <b>(2)</b>, which we reuse for both sides of the communication; it simply takes in a connected socket object and performs a receive. We then dump the contents <b>(3)</b> of the packet so that we can inspect it for anything interesting. Next we hand the output to our response_handler function <b>(4)</b>. Inside this function, you can modify the packet contents, perform fuzzing tasks, test for authentication issues, or whatever else your heart desires. There is a complimentary request_handler function that does the same for modifying outbound traffic as well. The final step is to send the received buffer to our local client. The rest of the proxy code is straightforward: we continually read from local, process, send to remote, read from remote, process, and send to local until there is no more data detected <b>(5)</b>. Let's put together the rest of our functions to complete our proxy.</h6>

    	<pre style="background-color:#111; color:white; margin: 50px 0px 50px; border: 5px solid darkgray;
border-radius: 1%;" >


<span style="font-size: 30px; color:white;">(1)</span>    	def hexdump(src, length=16):

    		results = []
    		digits = 4 if isinstance(src, unicode) else 2
    		<span style="color: crimson">#our for loop with three parameters (start, stop, step) starts at 0,
    		#stops at the len(src) and steps length times</span>
    		for i in xrange(0, len(src), length):
    			s = src[i:i+length]
    			hexa = b' '.join(["0%*X" % (digits, ord(x)) for x in s])
    			text = b''.join([x if 0x20 <= ord(x) < 0x7F else b'.' for x in s])
    			result.append( b"%04X %-*s %s" % (o, length*(digits +1), hexa, text))

    		<span style="color:yellow">print b'\n'.join(result)</span>


<span style="font-size: 30px; color:white;">(2)</span>		def receive_from(connection):
			buffer = ""

			<span style="color: crimson">#We set a 2 second timeout; depending on your target</span>
			<span style="color: crimson">#this may need to be adjusted</span>
			connection.settimeout(2)

				try:
					#keep reading into the buffer until there's not more data
					#or we timeout
					while True:

						data = connection.recv(4096)

						if not data:
							break
						buffer += data

				except:
				pass

				return buffer


		<span style="color: crimson">#modify any requests destined for the remote host</span>
<span style="font-size: 30px; color:white;">(3)</span>		def request_handler(buffer):
			<span style="color: crimson">#perform packet modifications</span>
			return buffer

		<span style="color: crimson">#modify any responses destined for the local host</span>
		def response_handler(buffer):
			<span style="color: crimson">#perform packet modifications</span>
			return buffer

    	</pre>

    	<h6>This is the final chunk of code to complete our proxy. First we create our hex dumping function <b>(1)</b> that will simply <u>output the packet details with both their hexadecimal values and ASCII-printable characters.</u> This is useful for understanding unknown protocols, finding user credentials in plaintext protocols, and much more. The receive_from function <b>(2)</b> is used both for <u>receiving local and remote data, and we simply pass in the socket object to be used.</u> By default, there is a two-second timeout set, which might be aggressive if you are proxying traffic to other countries or over lossy networks (increase the timeout as necessary). The rest of the function simply <u>handles receiving data until more data is detected on the other end of the connection</u>. Our last two functions <b>(3)</b> <b>(4)</b> <u>enable you to modify any traffic that is destined for either end of the proxy.</u> This can be useful, for example, if plaintext user credentials are being sent and you want to try to elevate privileges on an application by passing in admin instead of justin . Now that we have our proxy set up, let's take it for a spin.</h6>


    	<p>Black Hat python</p>

<h3>All together</h3>
<pre style="background-color:#111; color:white; margin: 50px 0px 50px; border: 5px solid darkgray;
">



import sys
import socket
import threading

def server_loop(local_host,local_port,remote_host,remote_port,receive_first):

	server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

	try:

		server.bind((local_host, local_port))

	except:

		print "[!!] Failed to listen on %s:%d" % (local_host,local_port)
		print "[!!] Check for other listening sockets or correct permissions."
		sys.exit(0)

	print "[*] Listening on %s:%d" % (local_host,local_port)
	server.listen(5)
	while True:

		client_socket, addr = server.accept()

		# print out the local connection information
		print "[==>] Received incoming connection from %s:%d" % (addr[0],addr[1])
		# start a thread to talk to the remote host
		proxy_thread = threading.Thread(target=proxy_handler, args=(client_socket,remote_host,remote_port,receive_first))
		proxy_thread.start()

def	proxy_handler(client_socket, remote_host, remote_port, receive_fist):

	#connect to the remote host
	remote_socket = socket.socket(socket.AF_INET, socket.SOCK_STEAM)
	remote_socket.connect((remote_host, remote_port))

	#receive data from the remote end if necessary
	if receive_first:

		remote_buffer = receive_from(remote_socket)
		hexdump(remote_buffer)

		#send it to our reponse handler
		remote_buffer = response_handler(remote_buffer)

		#if we have data to send to our local client, send it
	if len(remote_buffer):
		print "[<==] Sending %d bytes to localhost." % len(remote_buffer)
		client_socket.send(remote_buffer)
		#now lets loop and read from local, send to remote, send to local
		#rinse, wash, repeat
		while True:

			#read from localhost
			local_buffer = receive_from(client_socket)

			if len(local_buffer):

				print "[==>] Received %d bytes from localhost." % len(local_buffer)
				hexdump(local_buffer)

				#send it to our request handler
				local_buffer = request_handler(local_buffer)

				#send off the data to the remote host
				remote_socket.send(local_buffer)
				print "[==>] Sent to remote."

				#receive back the response

			if len(remote_buffer):

				print "[<==] Received %d bytes from remote." % len(remote_buffer)
				hexdump(remote_buffer)

				#send to our response handler
				remote_buffer = response_handler(remote_buffer)

				#send the response to the local socket
				client_socket.send(remote_buffer)

				print "[<==] Sent to localhost."

			# if no more data on either side, close the connections
			if not len(local_buffer) or not len(remote_buffer):
				client_socket.close()
				remote_socket.close()
				print "[*] No more data. Closing connections."
				break

def hexdump(src, length=16):

	results = []
	digits = 4 if isinstance(src, unicode) else 2
	#our for loop with three parameters (start, stop, step) starts at 0,
	#stops at the len(src) and steps length times
	for i in xrange(0, len(src), length):
		s = src[i:i+length]
		hexa = b' '.join(["0%*X" % (digits, ord(x)) for x in s])
		text = b' '.join([x if 0x20 <= ord(x) < 0x7F else b'.' for x in s])
		result.append( b"%04X %-*s %s" % (i, length*(digits +1), hexa, text))

	print b'\n'.join(result)

def receive_from(connection):
	buffer = ""

	#We set a 2 second timeout; depending on your target
	#this may need to be adjusted
	connection.settimeout(2)

	try:
		#keep reading into the buffer until there's not more data
		#or we timeout
		while True:

			data = connection.recv(4096)

			if not data:
				break

			buffer += data

	except:
		pass

	return buffer

#modify any requests destined for the remote host
def request_handler(buffer):
	#perform packet modifications
	return buffer

#modify any responses destined for the local host
def response_handler(buffer):
	#perform packet modifications
	return buffer



def main():

	#no fancy command-line parsing here
	if len(sys.argv[1:]) != 5:

		print "Usage: ./proxy.py [localhost] [localport] [remotehost] [remoteport] [receive_first]"
		print "Example: ./proxy.py 127.0.0.1 9000 10.12.132.1 9000 True"
		sys.exit(0)

	#setup local listening parameters
	local_host = sys.argv[1]
	local_port = int(sys.argv[2])


	# setup remote target
	remote_host = sys.argv[3]
	remote_port = int(sys.argv[4])

	# this tells our proxy to connect and receive data
	# before sending to the remote host
	receive_first = sys.argv[5]

	if "True" in receive_first:
		receive_first = True
	else:
		receive_first = False

	#now spin up our listening socket
	server_loop(local_host, local_port, remote_host, remote_port, receive_first)

main()






</pre>
		<img src="">


		</article>



		          <h2>Changing groups</h2>
          <p>first we check the groups using $groups</p>
          <img src="https://kctjdw.bn1301.livefilestore.com/y3mX7DKHnWhbT2cndPZtX1AM8K_jSJxXGjPBS--FBc4WDT2FVbE0K333RjXYb_8WAeuZt8xSfaCC15IkTt1oJK-acl2m2wEgeQRzR_acTJ5bpX8S5lGsMP1T3LjhZUaSBNta1C-6o8-tr0rWQYbWmWNVbpJlqvnydiECTyCIo0XfXg?width=656&height=30&cropmode=none">
          <p>sudo chown -R username:group directory</p>
          <p>Let's check out chown with $man chown</p>
          <p>we can see what the arg -R stands for:</p>
          <img src="https://kcrwkq.bn1301.livefilestore.com/y3mcvzDmvJUA_-M0doRjVtzb71-AAgaU8szMLYwtGs3QoBcqHRBV2_lWWvmmE7iqrDLwHAGx8nH_f2cUjDwmOGR2nEkRwVtw5pTPMV_qyxVRaQh8-VhaxZrXb_RX5350G3GY2KOKgNuxu1Il3OWlRT7MIufpbTHfSxjUOLXZG2Zn30?width=655&height=22&cropmode=none" >
          <p>And if we look at the bottom, cool it has some examples:</p>
          <img src="https://kctxbq.bn1301.livefilestore.com/y3m8QPXHO0ODpxnGLUWAJALkrrTj1tdvuRK0pzEi0nLGKWzW92OxnHsvFbh2gp1-0mG9Pd5FgoEjB6tjCL-4EMZ_t9aCl0XhN7V_dTd4CVn4CLJ70JAHuvrOlUbcoSiPeDgYtct_iAm4Gv9-EbzG0RdRhu3GscG5E4cdqfZYVXSVk4?width=653&height=74&cropmode=none" >
          <p>So now let's change our squid file permitions and group.</p>
          <img src="https://kcqgqa.bn1301.livefilestore.com/y3mHectkeg27pIWhtCxdnMwSXUhi887tE2AkhfF7lDU62u5ThDiAAyI1paqD44DSlyc6Pon0dNyTmVjmBIG21dJMhqTc3q4uZc7B80pI6Wtbd5DO23dw1O4iErkKSF3yR791NV7mSBxwOLZd2P9wM44M2bwT90uYDdPkmxOnBVbXFM?width=655&height=62&cropmode=none" >
          <p>Obviously we need root permissions to do so.</p>
          <p>Now if we check ours files again we can see that the owner and the group changed.</p>
          <img src="https://k5ks1g.bn1301.livefilestore.com/y3mRtID8qiuzIpjkav-ekCtJwxY_-J1SRShuLKZKVRRPAicj2c322W0M55DHfRMqfvyhuyicHyJEmP-0bgohfNCnsYqjriANkAjUmswRRDjtOVSARePR9hOeBH1yH24PDHjP37BTbq08mqWoSBMU4HZFwn58MnYi1HskXE1eon_Ghc?width=655&height=160&cropmode=none" >



                 <article>
          <h2>CTF training</h2>
          <p>The problem: having to loop through multiple folders and files, but since everything is a file in linux... You get the point. So, solution, bash script.</p>
          <pre>

          #!/bin/bash
          FILES=~/inhere/*
          do
          	echo "Processing $f file\n"
          	#to do
          	ls $f
          	for
          done

		      </pre>
          <p>The output looks like so.</p>
          <p>But this doesn't solve anything. Now we have to <b>cat</b> each file.</p>
          <pre>

          for f in $FILES
          do
            cd $f && cat -- *
          done

          </pre>

        </article>





		<article>
		  <h3>Found some old hardware</h3>
		  <h5>KM-T5-T1</h5>
		  <img src="https://k5nspq.bn1301.livefilestore.com/y3magwUUe7Yi1NPfYjikQKUFucp94lruqAg9vSVkPyEUDW4tU7U-O6dtczW6FtBqnTbGpqoKamDZ623MWdzVxjgy6eF2tH531nbNmfEw2S81xb5p503DURqEmV4xy9UiS52dfCr5b8XrAL1U4PDn2nW8bnyVeLYxCHSoC2QGIKn2I4?width=5184&height=3456&cropmode=none">
		  <h5>Camaro</h5>
		  <img src="https://7mgbng.bn1301.livefilestore.com/y3mGPLC8DBpPdJZLkId6UT_z-J6jx9Dkiwfo19tigkrXuDmW0KQ2nhQzcj7X7uKF5UwMt3e90VYW_W-z7C5PqRUeAEBRaCxJOvIEuqkdnxmRVpkGnKcy6rDZyaHkAjTMPQS1CVImdPr2rbdQYxy0kr-o6ZN93ghi9tQEM9Anbdvf7o?width=5184&height=3456&cropmode=none">
		  <h5>Intel Pentium 4</h5>
		  <img src="https://7mhfeg.bn1301.livefilestore.com/y3mQfuoI_gedrxjJX7gJnQcrZcoh7IRH7JRWdVHJsfRuE0_f05LSJAGpPd_qz6RreSPAZC-87Bm24aKhbSHc3HJHqfPG4UMpxf2Y6ah5aqOF2RxTedKqnjNeUfDznkyevEHyzeZcsTBgSHIhhDfgy9nxvuKOQNKAoVfWADavAus0DE?width=5184&height=3456&cropmode=none">
		  <h5>AMD K6-233ANR</h5>
		  <img src="https://7mivyw.bn1301.livefilestore.com/y3mWJpEU_LNKHlJlz4BDv6WfXz5SXIeV80goOGsDgiedGDwi0tjxpYWJq-GAd_uQcXO6eGdNLgLwA-j4lCDCVaWCYiO2M9GAuW1TuQ78bLAyq7NzCvDiTpMhLxt54hyISA8yYFSTt5a6kYDFT7uv9cVxQQtlEO65nNGiMDj95de_ic?width=5184&height=3456&cropmode=none">
		  <img src="https://7mjebq.bn1301.livefilestore.com/y3m5qimcrvaBfisPQ4sDtxcgalmLYvwjvTDz0RrvMzBUxOtoN6h5Tg2OeKpw3QcMAuqIdGN6gTIgejHYZ8EyX9iXfqlw1gA-TeS4QKPvPNJYPFNLaMnlOIQYmAQKKoISS4bVPVOdaj2505YTUArkKDbTYcBzgPR-YfzpRhslCxHGaY?width=5184&height=3456&cropmode=none">
		  <h5>AMD K6-2</h5>
		  <img src="https://7mj67g.bn1301.livefilestore.com/y3mbg0vOC8AulmJXOrvCNweN0s7-g_dx6CZC8tbV2qtJY19JDDJTyIC2UF40OleCd4D3T5M7OAUbbvpVRTrCgQPSOE8wxG3uz4G4DmKOHBzc8GoE7LBnX4vUE3aJMthaVUZM7Qpk0RmT6HAV49kAvLuXANenxvfJEO2CpeAGvgI5fg?width=5184&height=3456&cropmode=none">
		  <h5>RAM</h5>
		  <img src="https://hqvwza.bn1301.livefilestore.com/y3mdU1CuhU8fEERwmwDvkheCNHMgR6EGcUwRiYT7Lp5VGDlbLNoWKy4NEKdgniGxKTGmjTq2kCwXS6ixCg8PB3aV2mSR33YjWPUaNLF3yMTZujQuD_v9wURlAs7sGpDrdc7k-KEPAd99-7jD0nuNmbXvSQUIY990asN5ur44VZHgRQ?width=5184&height=3456&cropmode=none">
		  <img src="https://hqsmtg.bn1301.livefilestore.com/y3m0N-Y7xMghiNiBxYPqZORLJTyONepJ21NBQaSg7Ueky8KYa-_EHQSzmqMOucZXVT5eyYHZIKO2gEevn6SKPROdEjnfJbSI3ZWW4npirusf_4pPRFYux1hxDJZ3co5FZL7xh6gKEK66NGw2OLg1KSEWXJHb7DlWwbhO_AcPYYGqO0?width=5184&height=3456&cropmode=none">
		  <h5></h5>
		  <img src="https://hqtx2q.bn1301.livefilestore.com/y3mPOrlUh3CRrzRLvUGJjWVtYYB2YD4K590M119U5rk2yNQYzIdHhN9YqttmQEG5q58-Bk_MdCO3Zs--8hQazAcIghTrAiS-OR9CeZzwUWlGAgsjKpsbKlJbUCwXpL_-E77GZr35tQV4RWCk67VqysCgUB75lwHXa-y2cfRpVO-8KI?width=5184&height=3456&cropmode=none">
		  <h5></h5>
		  <img src="https://hqugew.bn1301.livefilestore.com/y3mWMYNCZA7i2zAY3iRdz_XRubaV5cqLLUn-asUVOE33HQpW4uNVFBLXa35Zjj41GNh0HOOvYaPXAB5nSqHf7XV840JGrdpTb6p-l2CPWdJja3uhpNy55dItWOYqAlpbXWkSt_sQJjmPObrNy7GggrBYbXL--K5BYH2c4Z3-R_b_uY?width=5184&height=3456&cropmode=none">
		</article>
		<article>
		  <h3>Endless screaming</h3>
		  <img src="https://gpzdza.bn1301.livefilestore.com/y3mUe_s5RI8eVa9AsPje3YJg35ovRfcGbwyx0Rp2ZjEDu9KlOiWBNEg_PLP639ar_h-99My0fLld0YEnDtBj8pcaeRSsWPm8bRXgIzYGMFIfRY6zm_4tPyewl5OkLfHFjisHbmin_SVnrQ4iH0sHoHVQ_lp1uMiz43f_ZX66wR9Yk8?width=674&height=548&cropmode=none">
		  <p>python</p>
		  <img src="https://gpb42a.bn1301.livefilestore.com/y3mPDCWq_fsOVVmeGJ6iqZvLkHZ3C-Hg2nEye7d4emrcnvm5PNXiSGP22d7gpIm-hb6VVh-JNyB_1_4w-gnkS7Utuk3xUQzGQBqhMeU_YVbCkigAPmSh2ayUoKAaXlAEcTJuk4SZNCgFNoeMvsMLQ1EHMXsyadm6_m-_8RjRFDYH5k?width=670&height=185&cropmode=none">
		</article>
		<article>
		  <h3>Oh gee</h3>
		  <img src="https://id0hhq.bn1301.livefilestore.com/y3mmmtRFONYaq0qjWbZJ2VEf8fhd-79FPNHMvlLsPs3rN6jW8hzlN0paZiHaKM-SQr99-iTX0AErC158mzpjQda7PIi7AsznFHLJ22NowycGee75Je5mqPfYb0hdkH0kLvR1PaZSkrS3INUFtuuaS-FGzfE6vYLlNrOqLbt-62VzfM?width=5184&height=3456&cropmode=none" style="width: 800px;">
		  <img src="https://k5kq1g.bn1301.livefilestore.com/y3mc98xYYQF1ankSWNBxrfbWxDl6MSSnGwskyw1p6AI1BoInpqvRA-LWEzNe_U7rckYLqFcNMLMb2eqLGR6WXeAWD7vFHr6bdndGl2GtHc4GlpY0CJhPvR8PuVm0cE4tgpJkknJ4-z0o9TkSSfh1Y_WBEZWKEhIEeP1shhZE2O9E1M?width=5184&height=3456&cropmode=none" style="width: 800px;">
		  <img src="https://k5lzea.bn1301.livefilestore.com/y3m0sae7oMCa5nOLpbMrAfWPGfEDXxWltKtReFgsynqzvm9_WB6kg_0IumiLF_uXRcNMxLAhRaYKgaaWqApHE6S34DgklRuk_PAUUwpYE2-0D9HVqMygXqcL94K9ujglgq1dW99_-bbN-zGS0u4fyJejG_U7Ruk693VGPO7aiFIjws?width=5184&height=3456&cropmode=none" style="width: 800px;">
		</article>
		<hr>
		<article>
		  <h2>First one</h2>
		  <p>This took me some time but i finally got it!</p>
		  <img src="https://kctovg.bn1301.livefilestore.com/y3mdHzrO2j1VOUd_9jtRufTYfsAOqxTvhP25kLryIW51K7tN91fLq6AsaSGlzWgNfD3n64Zm3hRAvB1QOhLgJcSjQTkw0JBoGDpXdQWboi_tzviwOtLuDm-DnoX2u5__zr4EdcIscppjPjXkAc_YbmAmTDOL-N64l8XMjVNTQV1XpQ?width=679&height=352&cropmode=none">
		</article>
		<hr>
		<article>
		  <h2>Variable Scoping</h2>
		  <p>Each function has its own set of local variables, which are independent of everything else.</p>
		  <ul>
			<li>
			  Local Variables - Declared inside a function or block. They can be used only by statements that are iside that function or block of code. <u>Local variables are not known to functions outside their own.</u>
			  <h2></h2>
			</li>
			<img src="https://9a9hyw.bn1301.livefilestore.com/y3mKrb877PGUnWzLu5NpCRIvdfweBvklscQ20lZQoulu_mO6RTOjiIyGyGH_7tJo389AMmglbDlk3oYf-2RjyTJ2Vo9l5_ZaZyMHHPx3QQZ9PzSJPqsO1C6UXQEUIvv2vw7EE5DRcfvFzO2RpCZVdiqrun9QDbpFh2_xiYNd7LbOmQ?width=656&height=108&cropmode=none" style="margin: 10px 0 10px">
			<h2></h2>
			<li>Global variables - Global variables are define outside a function.Global variables hold their values throughout the lifetime of your program and they can be accessed inside any of the functions defined for the program. <u>A global variable can be accessed by any function.</u>
			</li>
			<img src="https://9aplpw.bn1301.livefilestore.com/y3m26b5KOYAGtX5hQ5GadPITMD1nYoPSugKu8psn7W6uRCRwBd3O4aTyT25NsBVVO7lljgKIwzkBPONu_-OEPdEDd3hayEwLCWcKhEaEbXGJN3pfZq-980Vq701UwSEjiSScSZVeryTvXuUekD2ozZuZBYEtguz6X_RDK4HS605_Js?width=658&height=136&cropmode=none" style="margin: 10px 0 10px">
			<h2></h2>
		  </ul>
		  <img src="https://9a8kmw.bn1301.livefilestore.com/y3mJq1-FkaR3jUB6LtbH9zFMViuvYIXdxbbDQU1LURdtXXMXjHtg6AhkgGp28zGGJhJfYQFN9aREgicJQO1aH36V5AApNf0D0PGjm1NiFNp6YGHkIXBrxswlvmY_qVqtlbNnHatzzxZ1VFY4467MpOmGyZxVjA76gMxbWgngQd0l0A?width=655&height=443&cropmode=none">
		  <img src="https://9aps7g.bn1301.livefilestore.com/y3mU5BBi9nbiY6MDBvpBNVOSeq5y4rsNyo0GXo7_B3fyN9BkAVwgivoWSoQOP9avJ2aGxQPd85pwhiIOpkBaKuzPTcNetAZcl00hETNwdQXJgI4tDDWUJwd-LujO6p3OqHUi0SRECs0c-rzfWVTqfb0mOMlfy_hmVlHQ7R0vq3_0mw?width=655&height=134&cropmode=none" style="margin: 10px 0 10px">
		  <p>In each function, the variable <b>i</b> is set to a different value and printed. But <b>i</b> doesn't change when other functions are called because they are local to those function, therefore they can not be changed. Each function call has its own version of the variable <b>i</b>. </p>
		  <p>Let's check out global functions.</p>
		  <img src="https://9a9aha.bn1301.livefilestore.com/y3m3ruGCPMfmKKO5lyCaOOFwmF16hXTq2w-8R7b8bWWMShSzstish693ch8KD_GqtOtBxGgJkii0Omo_UGX-wPTMSo2ne7V5qpbF4QND_c9WegxeDX2PiRo7SjvaMWRI5_DTg6baCYW4WP7Q5n-2Zydw-Hkf3DYCTBkCOrMiz09zdw?width=655&height=489&cropmode=none">
		  <img src="https://9aqbka.bn1301.livefilestore.com/y3mH__dyMujaKs9PtllLrRPfp_AGwDGMglBiK87lZVtjAsI4uY5xZxYjcuc7U6hfBgZAeO653ehwKbOO_cJeTB8xhU-idnYwvDeUW8KW34AKWsbyE2FXKzFmLAhQhVgrV0jDVxqqgc2LevF2T4He6UKQIuFEvyGV94zAsw4ofzmosU?width=658&height=139&cropmode=none">
		  <p>In the output, the global variable j is written to in func2() , and the change persists in all functions except func3() , which has its own local variable called j .The global variable j is just stored in memory, and every function is able to access that memory. The local variables for each function are each stored in their own places in memory, regardless of the identical names.</p>
		  <p>Let's see this code in the debugger</p>
		  <p>If we disassemble main we can see the adding of 3 to i, the call to printf and the call to function1()</p>
		  <img src="https://wjuzeq.bn1301.livefilestore.com/y3m_l6H5zMAuK6nswS4teX0w2jFC5H2yIJTerWkoCTlpJ76y5XnMA42F2tJqw5QrT58C046PJ1v6ZyDw1Tb8CHTT-BIP93fx_nMDEhr3tCviqjJHAluOrU-RPzI40kzK-MTCVPjGhBFCwwvpYLUjpnIgPE3mxSfEKE74BikpvYxToQ?width=658&height=374&cropmode=none">
		  <img src="https://wjv3vq.bn1301.livefilestore.com/y3mNzKUS_gIJP_kTJZSQvKs3sz2ZNfdQc3z371bXeESRKIkf1RAIZHLoNDjfMe9cDb4KpjpnYvjTKfiDI3HPWy9Zj7uAzzoi9rs6aASifKCdQGqbRutfdiEf_o1gbUMonJTz5KlRQwgNm4HJoi6JEX2AweQs3DLCHMLpZNOj3c1nGI?width=659&height=661&cropmode=none">
		  <p>We are going to examine that instruction. That assembly instruction will move the value of 0x3 (3 in decimal) into memory located at the address stored in the RBP register, minus 0x4 (4). This is where the C variable <b>i</b> is stored in memory</p>
		  <p>Down below we check this process by going to the next instruction. At (..)0652 in main() we examine the memory, which at start is all 0's but and the next instruction (..)0659 in main() will have the value 3 in it</p>
		  <p></p>
		  <p>We can check this even closer with print. It stores the result in a temporary variable in the debugger <b>$2</b></p>
		  <img src="https://wjusmg.bn1301.livefilestore.com/y3mmOkKfXU3uqr_P0DbCpxhOxoqAeSL5P5XpceuPzYtFELcyMYvhv5ahCIjBkY8pqxuwbvlcZhwvYrIQNQUI7a6T3KFVGezKIQ9TNsvzy__zdqWyJGs0Q5YrM3XM0GmB9SlpEDDOvF3xH03YxUGdx8v8NC7DwRAE5PcwMVZxXfPsrI?width=653&height=74&cropmode=none">
		</article>
		<hr>
		<article>
		  <h2>Typecasting</h2>
		  <p>Type casting is a way to convert a variable from one data type to another data type.</p>
		  <p>Let's see this example.</p>
		  <img src="https://hqsntg.bn1301.livefilestore.com/y3mFljjbjgZ6Rdy5kxZzrt9EfN45rK_yfVGHi1kK3BMwQ_LzVFN5KZ3lGthSIsWYN2YBe__WxOvCZ9JyR5bxqxF5IhvzMYdi2MYYanS-HiN4aOeOvniQLqHbeWuvM0O6S2YXxJIAh02fdp-FWndA4ecs7GLtuQCVYIMwhpf5AqJ0hY?width=654&height=283&cropmode=none">
		  <img src="https://gpzxhq.bn1301.livefilestore.com/y3miGqHt5Muc5ksju4coZsGf42_c3_4AoLTWzr-dcSDrmVkYkClpVqlvpmL_V5zUDCvekYoBVh7yckoc-GSI0PK5qJ-M-uSN-gjCD2ra_B9HP6cSDdWW6BSuSUpHcKr822-5nJecvSREVypasrNym9zBupWzlZT-EMIf8agd6wO20M?width=654&height=72&cropmode=none">
		  <p>If you look at the output of the division using integers, we see that the result was rounded to the incorrect answer of 2, even if this value is being stored into a floating-point
			variable. But, if these integer variables are typecast into floats, they will be treated as such, therefore we get the correct calculation of 2.6.
		  </p>
		  <p>We'll look into typecasting with pointer variables.</p>
		  <p>Even though a pointer is just a memory address, the C compiler still demands a data type for every pointer. An integer pointer should only point to integer data, and a character pointer to a character data. Because if we look at pointer arithmetic, since an integer is four bytes (8 bytes if you're on a 64 bit system and 2 bytes on a 16 bit machine) and a character only takes up one byte.</p>
		  <img src="https://gpa8qa.bn1301.livefilestore.com/y3miO9-JSd7o7QEPemzWX-I5yfzZYiUijehpT-7VpIzEtlxq0m8IqG9s8r4lF8eFte18KSLeF1j9yuI4mcl5uvft8lxGl9MO9UW2ZEpnGA3vjz2uLDe-1s0jB55il2goMf-UxZwkCihM-DIPLwiPAZGtsSbeQizsiuzBJ41OnJxgPs?width=656&height=541&cropmode=none">
		  <p>The comments explain much of the code. Notice that in the loops, when the integer and character values Programming 53 are actually printed with the %d and %c format parameters, notice that the corresponding printf() arguments must dereference the pointer variables. Notice also that even though the same value of 1 is added to int_pointer and char_pointer in their respective loops, the compiler increments the pointer's addresses by different amounts.</p>
		  <img src="https://hqvxza.bn1301.livefilestore.com/y3maB29NxzIpnYY3bQD5Q4SfhDIFy8F9LnG9DQhJYEaEuWLHKtHXpqF3sxNF4PqQuy83XoZoue1KVgFQdb7rRSd_OZEhHt0B76yQhPZXPADHNuMVhQAFL8CNn0IyxpVPYJkneSgOUpx5y_fIKzPqShoPhnbHmqtHUPLg6kjvzawD0Q?width=656&height=145&cropmode=none">
		  <p>In this next example we make the pointers point to incompatible data types. In an attempt to prevent programming mistakes, the compiler gives warnings about this.</p>
		  <img src="https://hqtrkg.bn1301.livefilestore.com/y3mPzCBuMV5e7-ykO78ArJKNs0rg8aOyg0nE9NgSl_A9yyqjhBfblMtNX1xCbTyA6H0MDhnrtAx8og4vkE7GdiP4PrXzMyP0H7xSYsD94GaQvcJEySH0deL76YDnW233-5A7qcPMDj9Np7tZfeusIzc0Llk6jGllv6DF_nrK7rYSsE?width=654&height=110&cropmode=none">
		  <p></p>
		  <img src="https://hqty2q.bn1301.livefilestore.com/y3mtKJKw94xhdhBEtdNe0vb4utw3WPHhKvlJxNmfMBQdpGCDpo9G15stnHqheFvmcafi3B1USLvgdocgVKF1ewOv-fh2AZjwEeyAILTVXyMsWa5TOeuUNpheCf5XJTqGrS4_TuDDY3hIEs6g9vRUdY-C2cO588XHJXtQ_DaFDnZC1o?width=657&height=290&cropmode=none">
		  <p>However, in the compiled code, a pointer is nothing more than a memory address, so the compiler will still compile the code if a pointer points to an incompatible data type.</p>
		  <p>Even though the int_pointer points to character data that only contains 5 bytes of data, it is still typed as an integer. This means that adding 1 to the pointer will increment the address by 4 each time. Similarly, the char_pointer's address is only incremented by 1 each time, stepping through the 20 bytes of integer data (five 4-byte integers), one byte at a time. Once again, the little- endian byte order of the integer data is apparent when the 4-byte integer is examined one byte at a time. The 4-byte value of 0x00000001 is actually stored in memory as 0x01 , 0x00 , 0x00 , 0x00 .</p>
		  <p>We can fix this by typecasting.</p>
		  <img src="https://hquhew.bn1301.livefilestore.com/y3m5O1XYnupx7rx1_zSi2Ygzd7Olhks46qpW03HbWwoIaMH6G6M9UMCFagJFJflNYmCijfHFcDDHMf6v2YuEOipeiNJcZSBkvsC7FsGbW2-jSQHSXbTn6zjMp5AZDmsxWqg-xkdAEwSb-qXrR7xvpx1uq1GpOgZeTjHEORuUgP5F94?width=656&height=548&cropmode=none">
		  <p>Here, when the pointers are initially set, the data is typecasted into the pointer's data type. This way the C compiler won't complain about the conflicting data types, however the pointer arirthmetic will still be incorrect. To fix that, we need to cast the correct data type when 1 is added to the pointer, that way the address is incremented by the correct amount.</p>
		  <img src="https://hqvqhq.bn1301.livefilestore.com/y3mkdVpI7hO9mg9WgW72BtWURbyM46p4K4J-Gm1DmVpKc7VvAdGktH32_MVSsPAWjfdZO7RvxHfKwUPUUfBF66jsjIGOXCM_clXjFylaxSO45umXt_HC_Av2LuDj2RqkMVHuShrtE_D_IJ072dC0CQPfcyRfIz3LKd3sssYX5tUjYk?width=654&height=177&cropmode=none">
		  <h6>Typeless Pointer</h6>
		  <p>In C, a void pointer is a typeless pointer, defined by the
			void keyword.
		  </p>
		  <ul>
			<li>Pointers cannot be dereferenced unless they have a type.</li>
			<li>Void pointers must
			  also be typecast before doing pointer arithmetic.
			</li>
		  </ul>
		  <p>In the next program a single void pointer is used by typecasting it to the proper type of pointer each time it's used. The compiler knows that a void pointer is typeless, so any type of pointer can be stored in a void pointer without typecasting. This also means a void pointer must always be typecast when dereferencing it</p>
		  <img src="https://hqvqvw.bn1301.livefilestore.com/y3mB5DL4q_82UR-5xcMIY21yYnqmmPkg07xdL9ZOvkuiHFImm4tnEFDV3uhiEoljErJN_DUdjnM2NSxkHY1DcX9eg1uSYezsB9rS6Oa9KBrieBysOEfLqY0qkhDf3ULLP_bC_ofx_pVrsDb97lopieyUT_Vwjg4dOPxY_3yhcGf2ak?width=654&height=352&cropmode=none">
		  <img src="https://hqsgbw.bn1301.livefilestore.com/y3mnoSGr7qjXX4RmiUCxhUnhNNg6mFUFzb6s5D2RBLDhNOrtS1VwsX5sMWHOpRPcaPXwtPakY1axlPX4AjOg4tSjjDJ6KSmlVH3UWvHTrLYPSS0V7O-uk__DfRR5FL-46U1gyi9MKqRmPpxXsql5KJ-A5vA90EXZM2fPxOjGz-IcII?width=654&height=173&cropmode=none">
		  <p>The void pointer is really just holding the memory addresses, while the hard-coded typecasting is telling the compiler to use the proper types whenever the pointer is used. Since the type is taken care of by the typecasts, the void pointer is truly nothing more than a memory address. </p>
		</article>
		<hr>
		<article>
		  <h2>Pointers</h2>
		  <p>The EIP register is a pointer that "points" to the current instruction during a program's execution by containing its memory address. Since the physical memory cannot actually be moved, the information in it must be copied. But doing so can be very expensive in terms of computationally, and also from a memory stand point since space for the new destination copy must be saved of allocated before the souce can be copied.</p>
		  <p>Pointers solve this, instead of copying a large block of memory, we can simply pass around the address of the begining of that block of memory.</p>
		  <p>Pointers in C can be defined and used like any other variable type.</p>
		  <img src="https://gpautq.bn1301.livefilestore.com/y3mfIe2eW0UIWJFTqK8nnjcu5q55t7i2C8AV_QrkyP_ONjQY_02F09rLQufd_cDiISNf7dJKY4sxXET_Rah5-m3kuyx7gtHyZEjc3EQtyiZeNaV11dmR6wUPh7gXhwc9YVaU42L6lgzO43qBGfcHRAjlmHsR4ws05-F6OX_VOChhFY?width=656&height=284&cropmode=none">
		  <p>When you compile you are going to get this warning, so what is it?</p>
		  <img src="https://gpzlqw.bn1301.livefilestore.com/y3mwCOdE3rKpM9_QuPxok3xeaGi3N3fi_6iUm3VURFnjE0pykIZQnRYAJc3h25tGl1pA2_Y99lh0NeLCtqPLy47L3vu4Jm1tqELAYqOuxVCi--tH9GssWDWikREpW1QWZ0maytdTpI3vN8B-VgjBjfZQE1Yf-obyrrxdOf7qJxx62o?width=656&height=182&cropmode=none">
		  <p>This warning is gcc's way of telling you that it cannot verify the format string argument to the printf style function (printf, fprintf... etc). This warning is generated when the compiler can't manually peek into the string and ensure that everything will go as you intend during runtime.</p>
		  <p>You are taking a string generated at runtime and trying to print it. The warning you are getting is the compiler warning you that there could be a format specifier in the string. Say for eg "bad%sdata". In this case, the runtime will try to access a non-existent argument to match the %s. Even worse, this could be a user trying to exploit your program (causing it to read data that is not safe to read). -Sanjit Saluja</p>
		  <p>So let's fixed it.</p>
		  <img src="https://gpyvwg.bn1301.livefilestore.com/y3mCwaCBjZ4EgbnoZnzVLTnvwDgqu41KzMXhhJaNrQ1pQjtTmL8HIkfoTGE8Edsf10Utoav0pRuAOXRAAcB7xPj3BTRp-BV4GpvjfcS-aXENAbXy-Lo1o4i4rSlcdQ6vdlSzvPDNx41L4CA79zYn3iWt6C50fQ6FoXNAuutM6NGBxY?width=655&height=86&cropmode=none">
		  <p>Now let's take a look at this with GDB. We set a breakpoint after the "Hello, world!\n" string has been copied into the str_a buffer and the pointer variable is set to the beginning of it. </p>
		  <img src="https://gpbkng.bn1301.livefilestore.com/y3maagGTE0SvTWMrqvI8VythDAwRd6XcLUAwUfqqxF6Yc-VoIABKHZ32eSAbcNa5jdx3CplG8G-GXC8sD0zwR57DI995ApUtXyvqjPqm6qyL5hjvDGPMGbNGN6x4HzoWuem86ub27fbFWo9K9md23vYW5z4N09c0b_lFzcZHbDl1xw?width=653&height=503&cropmode=none">
		  <p>When the pointer is examined as a string, it's apparent that the given string is there and is located at memory address 0x6c6c6548 . Remember that the string itself isn't stored in the pointer variable-only the memory address 0x6c6c6548 is stored there. In order to see the actual data stored in the pointer variable, you must use the address-of operator. The address-of operator is a unary operator, which simply means it operates on a single argument. The ampersand (&). </p>
		  <img src="https://gpbd7w.bn1301.livefilestore.com/y3m8dijsGn96lwV6gG4Q2xN9CBqL5KRxH3yKmFVYBmkMSvjDQYYDbDHP2ptFknbs3DJbN41IBeuUsZj_ZqJAKDCejxspOJcAL1q2UvLlAXvuXOCIK0dEDeYZoYQfEDNvRXUVu5CYIJ3VU3IjR9sksQsLqF7qxcN8rIzMKJQ3Cf4Jqw?width=652&height=102&cropmode=none">
		  <p>We can see that the pointer variable is shown to be located at the address 0x7fffffffde00 in memory, and contains the address 0xffffde10</p>
		  <p></p>
		  <img src="https://gpb52a.bn1301.livefilestore.com/y3mSnTQSpPpTBYIyQdj9-ke_pWZvF9d7NgPmuKkAYJIx3Q4UBhwjreVZ-La0yeyHG9Ae-FnnzEfcp844rjWWdUJada8cfv_Ascao3eh8aGc_H5s-yzhcSmj5ZdSngj71zPT8Q7fz-lVsesSLCMg6V4gmnqjSFrjCpBo1jFiCSAItYY?width=655&height=391&cropmode=none">
		  <p>The first print command shows the value of int_var , and the second shows its address using the address-of operator. The next two print commands show that int_ptr contains the address of int_var , and they also show the address of the int_ptr</p>
		  <img src="">
		  <p>An additional unary operator called the dereference operator exists for use with pointers. This operator will return the data found in the address the pointer is pointing to, instead of the address itself.</p>
		  <img src="https://gpyoew.bn1301.livefilestore.com/y3mNVe6MBiGzCNC8Q38a-eO2chotie-tLFRNygBP3rvmv84BEW7TMtvFKOM1XrXaabdMc_gREcC4xffT9qxvvv_ucrsS75GhkLNW2XMKPQAcc4IsXdi12lgEOl3FKciUwhzUBNlv6lwfjNBLRmmcYbKBMyZZwd0Ou1p2XMfxEy0pSo?width=656&height=120&cropmode=none">
		</article>
		<hr>
		<article>
		  <h2>No Linux Ban
			No wall
		  </h2>
		  <p></p>
		  <img src="https://id1tqa.bn1301.livefilestore.com/y3mJBgAfd4syb0zA_rOtkO9m2NONp4NzGlyMGcnTYFxEU877BZHqR8Lsn7ACUbdNQLcE2GQqgsLXEF93N2g9y7A_0rTyWT1rgxRZBXQzZx812_sP-avQIYmYrBmJuoEwxvbTaCL1IgLNy3NtIlYc7JAVi38zkJ5jZtM0aiWKL1ZfhA?width=762&height=161&cropmode=none">
		  <img src="https://id0pbg.bn1301.livefilestore.com/y3mTWAv1qcjSaMq_qrvTtPyW3mXo85htGOCoHjd1KfE6snaxI1tQgquECeWCL-km6LozUrq_Ma-sNy6r5baHqCb6gHqzuBGDCRMbz1G4tFnBgYofsDGVlS_5DsM-rpZ8zGzHTmJqbnOn1Q2TYIEFGoCNX-5OiwpEsL-AiL6tkX5agk?width=660&height=171&cropmode=none">
		  <img src="https://id0b1g.bn1301.livefilestore.com/y3m0anpLDNfZcdKDJPoOMe3a7FBmpwbhvdraO1W-QKBVeJ1Wn3F2FNk3XRDNAOv_iLJwqaY85O4H7FW5Aj7vSX4GBF1JyegozbeQS9u3aNRiy8WrM1Z2J3gj2choCdvVpQ7vw_LKRe4S1-jw0oMtF3_tFgSyw73EJBHgqUWQkzjj4o?width=780&height=520&cropmode=none">
		</article>
		<hr>
