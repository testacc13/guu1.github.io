<!DOCTYPE html>
<html>
<title>Just python</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="http://www.w3schools.com/lib/w3.css">
<link rel="stylesheet" href="w3.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"><style>
body {font-family: "Roboto", sans-serif}
.w3-sidenav a {padding:16px;font-weight:bold}
</style>
<body>

<nav class="w3-sidenav w3-collapse w3-text-black w3-hover-text-black w3-animate-left w3-card-2" style="z-index:3;width:250px;" id="mySidenav">
  <!--<a href="#" class="w3-border-bottom w3-large"><img src="http://www.w3schools.com/images/w3schools.png" style="width:80%;"></a>-->
  <a href="javascript:void(0)" onclick="w3_close()" 
  class="w3-text-teal w3-hide-large w3-closenav w3-large">Close <i class="fa fa-remove"></i></a>
  <a href="../../index.html" class="w3-light-grey w3-medium">Home</a>
  <a href="just-python.html">Python</a>
    <div class="w3-accordion">
    <a onclick="myAccordion('demo')" href="javascript:void(0)">Networking <i class="fa fa-caret-down"></i></a>
    <div id="demo" class="w3-accordion-content w3-animate-left w3-padding">
      <a href="../Networking/protocols.html">Protocols</a>
      <a href="../Networking/apache.html">Apache</a>
      <a href="#">Link 3</a>
    </div>
  </div>
  <a href="../Casm/casm.html">C/ASM</a>
  <a href="../Linux/linux.html">Linux</a>
  <a href="../../posts.html">Photography</a>
  <a href="../Gaming/gaming.html">Gaming</a>


  <a href="../../about.html">About</a>
</nav>

<div class="w3-overlay w3-hide-large w3-animate-opacity" onclick="w3_close()" style="cursor:pointer" id="myOverlay"></div>

<div class="w3-main" style="margin-left:250px;">

	<div id="myTop" class="w3-top w3-container w3-padding-16 w3-theme w3-large">
	  <i class="fa fa-bars w3-opennav w3-hide-large w3-xlarge w3-margin-left w3-margin-right" onclick="w3_open()"></i>
	  <span id="myIntro" class="w3-hide">Home</span>
	</div>

	<header class="w3-container w3-theme w3-padding-64" style="padding-left:32px">
	  <h1 class="w3-xxxlarge w3-padding-16">Just python</h1>
	</header>

	<div class="w3-container w3-padding-32" style="padding-left:32px">

			<hr>
					<article>
		<h2>Building a TCP Proxy</h2>
		<h6>There are a number of reasons to have a TCP proxy in your tool belt, both for forwarding traffic to
bounce from host to host, but also when assessing network-based software. When performing penetration tests in enterprise environments, you'll commonly be faced with the fact that you can't run Wireshark, that you can't load drivers to sniff the loopback on Windows, or that network segmentation prevents you from running your tools directly against your target host. I have employed a simple Python proxy in a number of cases to help understand unknown protocols, modify traffic being sent to an application, and create test cases for fuzzers. Let's get to it.</h6>
	<p></p>
	<pre style="background-color:#111; color:white; margin: 50px 0px 50px;border: 5px solid darkgray; 
border-radius: 1%; ">


	import sys	
	import socket
	import threading

	def server_loop(local_host,local_port,remote_host,remote_port,receive_first):

		<span style="text-decoration: underline;">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span>

		try:

			<span style="text-decoration: underline;">server.bind((local_host, local_port))</span>

		except:

			<span style="color:yellow">print "[!!] Failed to listen on %s:%d" % (local_host,local_port)</span>
			<span style="color:yellow">print "[!!] Check for other listening sockets or correct permissions."</span>
			sys.exit(0)
			<span style="color:yellow">print "[*] Listening on %s:%d" % (local_host,local_port)</span>
			<span style="text-decoration: underline;">server.listen(5)</span>

		while True:

		            <span style="text-decoration: underline;">client_socket, addr = server.accept()</span>

		            <span style="color:crimson"># print out the local connection information</span>
		            <span style="color:yellow">print "[==>] Received incoming connection from %s:%d" % (addr[0],addr[1])</span>
		            <span style="color:crimson"># start a thread to talk to the remote host</span>
		            proxy_thread = threading.Thread(target=proxy_handler, args=(
		            client_socket,remote_host,remote_port,receive_first))
		            proxy_thread.start

     def main():

     	<span style="color:crimson">#no fancy command-line parsing here</span>
     	if len(sys.argv[1:]) !0 5:

     		<span style="color:yellow">print "Usage: ./proxy.py [localhost] [localport] [remotehost] [remoteport] [receive_first]"</span>
 			<span style="color:yellow">print "Example: ./proxy.py 127.0.0.1 9000 10.12.132.1 9000 True"</span>
 			sys.exit(0)

 		<span style="color:crimson">setup local listening parameters</span>
 		local_host = sys.argv[1]
 		local_port = int(sys.agrv[2])


 		<span style="color:crimson"># setup remote target</span>
    	remote_host = sys.argv[3]
    	remote_port = int(sys.argv[4])

    	<span style="color:crimson"># this tells our proxy to connect and receive data</span>
    	<span style="color:crimson"># before sending to the remote host</span>
    	receive_first = sys.argv[5]

    	if "True" in receive_first:
    		receive_first = True
    	else:
    		receive_first = False

    	<span style="color:crimson">#now spin up our listening socket</span>
    	server_loop(local_host, local_port, remove_host, remote_port, receive_first)

    	#Call main
    	main()

    	</pre>

    	<h6>Most of this should look familiar: we take in some command-line arguments and then fire up a server loop that listens for connections. When a fresh connection request comes in, we hand it off to our <span style="text-decoration: underline;">proxy_handler, which does all of the sending and receiving of juicy bits to either side of the data stream.</span> Let's dive into the proxy_handler function now by adding the following code above our main function.</h6>

    	<pre style="background-color:#111; color:white; margin: 50px 0px 50px; border: 5px solid darkgray;
border-radius: 1%;" >
		


		def	proxy_handler(client_socket, remote_host, remote_port, receive_fist):	

		<span style="color:crimson">#connect to the remote host</span>
		<span style="text-decoration: underline;">remote_socket = socket.socket(socket.AF_INET, socket.SOCK_STEAM)</span>
		<span style="text-decoration: underline;">remote_socket.connect((remote_host, remote_port))</span>

		<span style="color:crimson">#receive data from the remote end if necessary</span>
<span style="font-size: 30px; color:white;">(1)</span>		if receive_first:

<span style="font-size: 30px; color:white;">(2)</span>			remove_buffer = <span style="text-decoration: underline;">receive_from(remote_socket)</span>
<span style="font-size: 30px; color:white;">(3)</span>			hexdump(remote_buffer)

			<span style="color:crimson">#send it to our reponse handler</span>
<span style="font-size: 30px; color:white;">(4)</span>			remote_buffer = response_handler(remove_buffer)

			<span style="color:crimson">#if we have data to send to our local client, send it</span>
			if len(remove_buffer):
			<span style="color:yellow">print "[<==] Sending %d bytes to localhost." % len(remote_buffer)</span>	
			client_socket.send(remote_buffer)
		<span style="color:crimson">#now lets loop and read from local, send to remote, send to local</span>
		<span style="color:crimson">#rinse, wash, repeat</span>
		while True:

			<span style="color:crimson">#read from localhost</span>
			local_buffer = <span style="text-decoration: underline;">receive_from(client_socket)</span>

			if len(local_buffer):

				<span style="color: yellow">print "[==>] Received %d bytes from localhost." % len(local_buffer"</span>
				hexdump(local_buffer)

				<span style="color:crimson">#send it to our request handler</span>
				local_buffer = request_handler(local_buffer)

				<span style="color:crimson">send off the data to the remote host</span>
				remote_socket.<span style="text-decoration: underline;">send(local_buffer)</span>
				<span style="color: yellow">print "[==>] Sent to remote."</span>

				<span style="color:crimson">#receive back the response</span>

			if len(remote_buffer):

				<span style="color:yellow">print "[<==] Received %d bytes from remote." % len(remote_buffer)</span>
				hexdump(remote_buffer)

				<span style="color:crimson">#send to our response handler</span>
				remote_buffer = response_handler(remote_buffer)

				<span style="color:crimson">#send the response to the local socket</span>
				client_socket.send(remote_buffer)

				<span style="color:yellow">print "[<==] Sent to localhost."</span>

				<span style="color: crimson"># if no more data on either side, close the connections</span>
<span style="font-size: 30px; color:white;">(5)</span>				if not len(local_buffer) or not len(remote_buffer):
					client_socket.close()
					remote_socket.close()
					<span style="color: yellow">print "[*] No more data. Closing connections."</span>
					break


    	</pre> 
    	<h6>This function contains the bulk of the logic for our proxy. To start off, we check to make sure we don't need to first initiate a connection to the remote side and request data before going into our main loop <b>(1)</b>. Some server daemons will expect you to do this first (FTP servers typically send a banner first, for example). We then use our receive_from function <b>(2)</b>, which we reuse for both sides of the communication; it simply takes in a connected socket object and performs a receive. We then dump the contents <b>(3)</b> of the packet so that we can inspect it for anything interesting. Next we hand the output to our response_handler function <b>(4)</b>. Inside this function, you can modify the packet contents, perform fuzzing tasks, test for authentication issues, or whatever else your heart desires. There is a complimentary request_handler function that does the same for modifying outbound traffic as well. The final step is to send the received buffer to our local client. The rest of the proxy code is straightforward: we continually read from local, process, send to remote, read from remote, process, and send to local until there is no more data detected <b>(5)</b>. Let's put together the rest of our functions to complete our proxy.</h6>

    	<pre style="background-color:#111; color:white; margin: 50px 0px 50px; border: 5px solid darkgray;
border-radius: 1%;" >
    	

<span style="font-size: 30px; color:white;">(1)</span>    	def hexdump(src, length=16):

    		results = []
    		digits = 4 if isinstance(src, unicode) else 2
    		<span style="color: crimson">#our for loop with three parameters (start, stop, step) starts at 0,
    		#stops at the len(src) and steps length times</span>
    		for i in xrange(0, len(src), length):
    			s = src[i:i+length]
    			hexa = b' '.join(["0%*X" % (digits, ord(x)) for x in s])
    			text = b''.join([x if 0x20 <= ord(x) < 0x7F else b'.' for x in s])
    			result.append( b"%04X %-*s %s" % (o, length*(digits +1), hexa, text))

    		<span style="color:yellow">print b'\n'.join(result)</span>


<span style="font-size: 30px; color:white;">(2)</span>		def receive_from(connection):
			buffer = ""

			<span style="color: crimson">#We set a 2 second timeout; depending on your target</span>
			<span style="color: crimson">#this may need to be adjusted</span>
			connection.settimeout(2)

				try:
					#keep reading into the buffer until there's not more data
					#or we timeout
					while True:

						data = connection.recv(4096)

						if not data:
							break
						buffer += data

				except:
				pass

				return buffer


		<span style="color: crimson">#modify any requests destined for the remote host</span>
<span style="font-size: 30px; color:white;">(3)</span>		def request_handler(buffer):
			<span style="color: crimson">#perform packet modifications</span>
			return buffer

		<span style="color: crimson">#modify any responses destined for the local host</span>
		def response_handler(buffer):
			<span style="color: crimson">#perform packet modifications</span>
			return buffer

    	</pre>

    	<h6>This is the final chunk of code to complete our proxy. First we create our hex dumping function <b>(1)</b> that will simply <u>output the packet details with both their hexadecimal values and ASCII-printable characters.</u> This is useful for understanding unknown protocols, finding user credentials in plaintext protocols, and much more. The receive_from function <b>(2)</b> is used both for <u>receiving local and remote data, and we simply pass in the socket object to be used.</u> By default, there is a two-second timeout set, which might be aggressive if you are proxying traffic to other countries or over lossy networks (increase the timeout as necessary). The rest of the function simply <u>handles receiving data until more data is detected on the other end of the connection</u>. Our last two functions <b>(3)</b> <b>(4)</b> <u>enable you to modify any traffic that is destined for either end of the proxy.</u> This can be useful, for example, if plaintext user credentials are being sent and you want to try to elevate privileges on an application by passing in admin instead of justin . Now that we have our proxy set up, let's take it for a spin.</h6>


    	<p>Black Hat python</p>

<h3>All together</h3>
<pre style="background-color:#111; color:white; margin: 50px 0px 50px; border: 5px solid darkgray;
">



	import sys	
	import socket
	import threading

	def server_loop(local_host,local_port,remote_host,remote_port,receive_first):

		server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

		try:

			server.bind((local_host, local_port))

		except:

			print "[!!] Failed to listen on %s:%d" % (local_host,local_port)
			print "[!!] Check for other listening sockets or correct permissions."
			sys.exit(0)

		print "[*] Listening on %s:%d" % (local_host,local_port)
		server.listen(5)
		while True:

			client_socket, addr = server.accept()

			# print out the local connection information
			print "[==>] Received incoming connection from %s:%d" % (addr[0],addr[1])
			# start a thread to talk to the remote host
			proxy_thread = threading.Thread(target=proxy_handler, args=(
			client_socket,remote_host,remote_port,receive_first))
			proxy_thread.start()

	def	proxy_handler(client_socket, remote_host, remote_port, receive_fist):

		#connect to the remote host
		remote_socket = socket.socket(socket.AF_INET, socket.SOCK_STEAM)
		remote_socket.connect((remote_host, remote_port))

		#receive data from the remote end if necessary
		if receive_first:

			remove_buffer = receive_from(remote_socket)
			hexdump(remote_buffer)

			#send it to our reponse handler
			remote_buffer = response_handler(remove_buffer)

			#if we have data to send to our local client, send it
		if len(remove_buffer):
			print "[<==] Sending %d bytes to localhost." % len(remote_buffer)	
			client_socket.send(remote_buffer)
			#now lets loop and read from local, send to remote, send to local
			#rinse, wash, repeat
			while True:

				#read from localhost
				local_buffer = receive_from(client_socket)

				if len(local_buffer):

					print "[==>] Received %d bytes from localhost." % len(local_buffer)
					hexdump(local_buffer)

					#send it to our request handler
					local_buffer = request_handler(local_buffer)

					#send off the data to the remote host
					remote_socket.send(local_buffer)
					print "[==>] Sent to remote."

					#receive back the response

				if len(remote_buffer):

					print "[<==] Received %d bytes from remote." % len(remote_buffer)
					hexdump(remote_buffer)

					#send to our response handler
					remote_buffer = response_handler(remote_buffer)

					#send the response to the local socket
					client_socket.send(remote_buffer)

					print "[<==] Sent to localhost."

				# if no more data on either side, close the connections
				if not len(local_buffer) or not len(remote_buffer):
					client_socket.close()
					remote_socket.close()
					print "[*] No more data. Closing connections."
					break

	def hexdump(src, length=16):

		results = []
		digits = 4 if isinstance(src, unicode) else 2
		#our for loop with three parameters (start, stop, step) starts at 0,
		#stops at the len(src) and steps length times
		for i in xrange(0, len(src), length):
			s = src[i:i+length]
			hexa = b' '.join(["0%*X" % (digits, ord(x)) for x in s])
			text = b''.join([x if 0x20 <= ord(x) < 0x7F else b'.' for x in s])
			result.append( b"%04X %-*s %s" % (o, length*(digits +1), hexa, text))

		print b'\n'.join(result)

	def receive_from(connection):
		buffer = ""

		#We set a 2 second timeout; depending on your target
		#this may need to be adjusted
		connection.settimeout(2)

		try:
			#keep reading into the buffer until there's not more data
			#or we timeout
			while True:

				data = connection.recv(4096)

				if not data:
					break

				buffer += data

		except:
			pass

		return buffer

	#modify any requests destined for the remote host
	def request_handler(buffer):
		#perform packet modifications
		return buffer

	#modify any responses destined for the local host
	def response_handler(buffer):
		#perform packet modifications
		return buffer



	def main():

		#no fancy command-line parsing here
		if len(sys.argv[1:]) != 5:

			print "Usage: ./proxy.py [localhost] [localport] [remotehost] [remoteport] [receive_first]"
			print "Example: ./proxy.py 127.0.0.1 9000 10.12.132.1 9000 True"
			sys.exit(0)

		#setup local listening parameters
		local_host = sys.argv[1]
		local_port = int(sys.agrv[2])


		# setup remote target
		remote_host = sys.argv[3]
		remote_port = int(sys.argv[4])

		# this tells our proxy to connect and receive data
		# before sending to the remote host
		receive_first = sys.argv[5]

		if "True" in receive_first:
			receive_first = True
		else:
			receive_first = False

		#now spin up our listening socket
		server_loop(local_host, local_port, remove_host, remote_port, receive_first)

	main()




</pre>
		<img src="">
		

		</article>
		<hr>
			
	<br>
	</div>

		<footer class="w3-container w3-theme w3-padding-32" style="padding-left:32px">
	  		<address style="color:white;">Apache/2.4.25 (Unix) Server on raspberrypi at brainpasta.ddns.net Port 80</address>
	  	</footer>   
</div>

<script>
// Open and close the sidenav on medium and small screens
function w3_open() {
    document.getElementById("mySidenav").style.display = "block";
    document.getElementById("myOverlay").style.display = "block";
}
function w3_close() {
    document.getElementById("mySidenav").style.display = "none";
    document.getElementById("myOverlay").style.display = "none";
}

// Change style of top container on scroll
window.onscroll = function() {myFunction()};
function myFunction() {
    if (document.body.scrollTop > 80 || document.documentElement.scrollTop > 80) {
        document.getElementById("myTop").classList.add("w3-card-4", "w3-animate-opacity");
        document.getElementById("myIntro").classList.add("w3-show-inline-block");
    } else {
        document.getElementById("myIntro").classList.remove("w3-show-inline-block");
        document.getElementById("myTop").classList.remove("w3-card-4", "w3-animate-opacity");
    }
}

// Accordions
function myAccordion(id) {
    var x = document.getElementById(id);
    if (x.className.indexOf("w3-show") == -1) {
        x.className += " w3-show";
        x.previousElementSibling.className += " w3-theme";
    } else { 
        x.className = x.className.replace("w3-show", "");
        x.previousElementSibling.className = 
        x.previousElementSibling.className.replace(" w3-theme", "");
    }
}
</script>
     
</body>
</html> 