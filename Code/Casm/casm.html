<!DOCTYPE html>
<html>
<title>C and assembler</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="http://www.w3schools.com/lib/w3.css">
<link rel="stylesheet" href="w3.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"><style>
body {font-family: "Roboto", sans-serif}
.w3-sidenav a {padding:16px;font-weight:bold}
</style>
<body>

<nav class="w3-sidenav w3-collapse w3-text-black w3-hover-text-black w3-animate-left w3-card-2" style="z-index:3;width:250px;" id="mySidenav">
  <!--<a href="#" class="w3-border-bottom w3-large"><img src="http://www.w3schools.com/images/w3schools.png" style="width:80%;"></a>-->
  <a href="javascript:void(0)" onclick="w3_close()" 
  class="w3-text-teal w3-hide-large w3-closenav w3-large">Close <i class="fa fa-remove"></i></a>
  <a href="../../index.html" class="w3-light-grey w3-medium">Home</a>
  <a href="../Python/just-python.html">Python</a>
    <div class="w3-accordion">
    <a onclick="myAccordion('demo')" href="javascript:void(0)">Networking <i class="fa fa-caret-down"></i></a>
    <div id="demo" class="w3-accordion-content w3-animate-left w3-padding">
      <a href="../Networking/protocols.html">Protocols</a>
      <a href="../Networking/apache.html">Apache</a>
      <a href="#">Link 3</a>
    </div>
  </div>
  <a href="#">C/ASM</a>
  <a href="../Linux/linux.html">Linux</a>
  <a href="../../posts.html">Photography</a>
  <a href="#">Gaming</a>


  <a href="#">About</a>
</nav>

<div class="w3-overlay w3-hide-large w3-animate-opacity" onclick="w3_close()" style="cursor:pointer" id="myOverlay"></div>

<div class="w3-main" style="margin-left:250px;">

	<div id="myTop" class="w3-top w3-container w3-padding-16 w3-theme w3-large">
	  <i class="fa fa-bars w3-opennav w3-hide-large w3-xlarge w3-margin-left w3-margin-right" onclick="w3_open()"></i>
	  <span id="myIntro" class="w3-hide">Home</span>
	</div>

	<header class="w3-container w3-theme w3-padding-64" style="padding-left:32px">
	  <h1 class="w3-xxxlarge w3-padding-16">C / ASM</h1>
	</header>

	<div class="w3-container w3-padding-32" style="padding-left:32px">

	<article>
		<h2>Typecasting</h2>
		<p>Type casting is a way to convert a variable from one data type to another data type.</p>
		<p>Let's see this example.</p>
		<img src="https://hqsntg.bn1301.livefilestore.com/y3mFljjbjgZ6Rdy5kxZzrt9EfN45rK_yfVGHi1kK3BMwQ_LzVFN5KZ3lGthSIsWYN2YBe__WxOvCZ9JyR5bxqxF5IhvzMYdi2MYYanS-HiN4aOeOvniQLqHbeWuvM0O6S2YXxJIAh02fdp-FWndA4ecs7GLtuQCVYIMwhpf5AqJ0hY?width=654&height=283&cropmode=none">
		<img src="https://gpzxhq.bn1301.livefilestore.com/y3miGqHt5Muc5ksju4coZsGf42_c3_4AoLTWzr-dcSDrmVkYkClpVqlvpmL_V5zUDCvekYoBVh7yckoc-GSI0PK5qJ-M-uSN-gjCD2ra_B9HP6cSDdWW6BSuSUpHcKr822-5nJecvSREVypasrNym9zBupWzlZT-EMIf8agd6wO20M?width=654&height=72&cropmode=none">
		<p>If you look at the output of the division using integers, we see that the result was rounded to the incorrect answer of 2, even if this value is being stored into a floating-point 
variable. But, if these integer variables are typecast into floats, they will be treated as such, therefore we get the correct calculation of 2.6.</p>
		<p>We'll look into typecasting with pointer variables.</p>
		<p>Even though a pointer is just a memory address, the C compiler still demands a data type for every pointer. An integer pointer should only point to integer data, and a character pointer to a character data. Because if we look at pointer arithmetic, since an integer is four bytes (8 bytes if you're on a 64 bit system and 2 bytes on a 16 bit machine) and a character only takes up one byte.</p>

		<img src="https://gpa8qa.bn1301.livefilestore.com/y3miO9-JSd7o7QEPemzWX-I5yfzZYiUijehpT-7VpIzEtlxq0m8IqG9s8r4lF8eFte18KSLeF1j9yuI4mcl5uvft8lxGl9MO9UW2ZEpnGA3vjz2uLDe-1s0jB55il2goMf-UxZwkCihM-DIPLwiPAZGtsSbeQizsiuzBJ41OnJxgPs?width=656&height=541&cropmode=none">

		<p>The comments explain much of the code. Notice that in the loops, when the integer and character values Programming 53 are actually printed with the %d and %c format parameters, notice that the corresponding printf() arguments must dereference the pointer variables. Notice also that even though the same value of 1 is added to int_pointer and char_pointer in their respective loops, the compiler increments the pointer's addresses by different amounts.</p>
		<img src="https://hqvxza.bn1301.livefilestore.com/y3maB29NxzIpnYY3bQD5Q4SfhDIFy8F9LnG9DQhJYEaEuWLHKtHXpqF3sxNF4PqQuy83XoZoue1KVgFQdb7rRSd_OZEhHt0B76yQhPZXPADHNuMVhQAFL8CNn0IyxpVPYJkneSgOUpx5y_fIKzPqShoPhnbHmqtHUPLg6kjvzawD0Q?width=656&height=145&cropmode=none">

		<p>In this next example we make the pointers point to incompatible data types. In an attempt to prevent programming mistakes, the compiler gives warnings about this.</p> 

		<img src="https://hqtrkg.bn1301.livefilestore.com/y3mPzCBuMV5e7-ykO78ArJKNs0rg8aOyg0nE9NgSl_A9yyqjhBfblMtNX1xCbTyA6H0MDhnrtAx8og4vkE7GdiP4PrXzMyP0H7xSYsD94GaQvcJEySH0deL76YDnW233-5A7qcPMDj9Np7tZfeusIzc0Llk6jGllv6DF_nrK7rYSsE?width=654&height=110&cropmode=none">
		<p></p>

		<img src="https://hqty2q.bn1301.livefilestore.com/y3mtKJKw94xhdhBEtdNe0vb4utw3WPHhKvlJxNmfMBQdpGCDpo9G15stnHqheFvmcafi3B1USLvgdocgVKF1ewOv-fh2AZjwEeyAILTVXyMsWa5TOeuUNpheCf5XJTqGrS4_TuDDY3hIEs6g9vRUdY-C2cO588XHJXtQ_DaFDnZC1o?width=657&height=290&cropmode=none">

		<p>However, in the compiled code, a pointer is nothing more than a memory address, so the compiler will still compile the code if a pointer points to an incompatible data type.</p>

		<p>Even though the int_pointer points to character data that only contains 5 bytes of data, it is still typed as an integer. This means that adding 1 to the pointer will increment the address by 4 each time. Similarly, the char_pointer's address is only incremented by 1 each time, stepping through the 20 bytes of integer data (five 4-byte integers), one byte at a time. Once again, the little- endian byte order of the integer data is apparent when the 4-byte integer is examined one byte at a time. The 4-byte value of 0x00000001 is actually stored in memory as 0x01 , 0x00 , 0x00 , 0x00 .</p>

		<p>We can fix this by typecasting.</p>

		<img src="https://hquhew.bn1301.livefilestore.com/y3m5O1XYnupx7rx1_zSi2Ygzd7Olhks46qpW03HbWwoIaMH6G6M9UMCFagJFJflNYmCijfHFcDDHMf6v2YuEOipeiNJcZSBkvsC7FsGbW2-jSQHSXbTn6zjMp5AZDmsxWqg-xkdAEwSb-qXrR7xvpx1uq1GpOgZeTjHEORuUgP5F94?width=656&height=548&cropmode=none">

		<p>Here, when the pointers are initially set, the data is typecasted into the pointer's data type. This way the C compiler won't complain about the conflicting data types, however the pointer arirthmetic will still be incorrect. To fix that, we need to cast the correct data type when 1 is added to the pointer, that way the address is incremented by the correct amount.</p>

		<img src="https://hqvqhq.bn1301.livefilestore.com/y3mkdVpI7hO9mg9WgW72BtWURbyM46p4K4J-Gm1DmVpKc7VvAdGktH32_MVSsPAWjfdZO7RvxHfKwUPUUfBF66jsjIGOXCM_clXjFylaxSO45umXt_HC_Av2LuDj2RqkMVHuShrtE_D_IJ072dC0CQPfcyRfIz3LKd3sssYX5tUjYk?width=654&height=177&cropmode=none">

		<h6>Typeless Pointer</h6>
		<p>In C, a void pointer is a typeless pointer, defined by the 
void keyword.</p>
		<ul>
			<li>Pointers cannot be dereferenced unless they have a type.</li>
			<li>Void pointers must 
also be typecast before doing pointer arithmetic. </li>
		</ul>
		<p>In the next program a single void pointer is used by typecasting it to the proper type of pointer each time it's used. The compiler knows that a void pointer is typeless, so any type of pointer can be stored in a void pointer without typecasting. This also means a void pointer must always be typecast when dereferencing it</p>

		<img src="https://hqvqvw.bn1301.livefilestore.com/y3mB5DL4q_82UR-5xcMIY21yYnqmmPkg07xdL9ZOvkuiHFImm4tnEFDV3uhiEoljErJN_DUdjnM2NSxkHY1DcX9eg1uSYezsB9rS6Oa9KBrieBysOEfLqY0qkhDf3ULLP_bC_ofx_pVrsDb97lopieyUT_Vwjg4dOPxY_3yhcGf2ak?width=654&height=352&cropmode=none">
		<img src="https://hqsgbw.bn1301.livefilestore.com/y3mnoSGr7qjXX4RmiUCxhUnhNNg6mFUFzb6s5D2RBLDhNOrtS1VwsX5sMWHOpRPcaPXwtPakY1axlPX4AjOg4tSjjDJ6KSmlVH3UWvHTrLYPSS0V7O-uk__DfRR5FL-46U1gyi9MKqRmPpxXsql5KJ-A5vA90EXZM2fPxOjGz-IcII?width=654&height=173&cropmode=none">



	</article>
	<hr>








		<article>
			<h2>Pointers</h2>
			<p>The EIP register is a pointer that "points" to the current instruction during a program's execution by containing its memory address. Since the physical memory cannot actually be moved, the information in it must be copied. But doing so can be very expensive in terms of computationally, and also from a memory stand point since space for the new destination copy must be saved of allocated before the souce can be copied.</p>
			<p>Pointers solve this, instead of copying a large block of memory, we can simply pass around the address of the begining of that block of memory.</p>
			<p>Pointers in C can be defined and used like any other variable type.</p>

		<img src="https://gpautq.bn1301.livefilestore.com/y3mfIe2eW0UIWJFTqK8nnjcu5q55t7i2C8AV_QrkyP_ONjQY_02F09rLQufd_cDiISNf7dJKY4sxXET_Rah5-m3kuyx7gtHyZEjc3EQtyiZeNaV11dmR6wUPh7gXhwc9YVaU42L6lgzO43qBGfcHRAjlmHsR4ws05-F6OX_VOChhFY?width=656&height=284&cropmode=none">
		
		<p>When you compile you are going to get this warning, so what is it?</p>
		<img src="https://gpzlqw.bn1301.livefilestore.com/y3mwCOdE3rKpM9_QuPxok3xeaGi3N3fi_6iUm3VURFnjE0pykIZQnRYAJc3h25tGl1pA2_Y99lh0NeLCtqPLy47L3vu4Jm1tqELAYqOuxVCi--tH9GssWDWikREpW1QWZ0maytdTpI3vN8B-VgjBjfZQE1Yf-obyrrxdOf7qJxx62o?width=656&height=182&cropmode=none">
		<p>This warning is gcc's way of telling you that it cannot verify the format string argument to the printf style function (printf, fprintf... etc). This warning is generated when the compiler can't manually peek into the string and ensure that everything will go as you intend during runtime.</p>
		<p>You are taking a string generated at runtime and trying to print it. The warning you are getting is the compiler warning you that there could be a format specifier in the string. Say for eg "bad%sdata". In this case, the runtime will try to access a non-existent argument to match the %s. Even worse, this could be a user trying to exploit your program (causing it to read data that is not safe to read). -Sanjit Saluja</p>
		<p>So let's fixed it.</p>
		<img src="https://gpyvwg.bn1301.livefilestore.com/y3mCwaCBjZ4EgbnoZnzVLTnvwDgqu41KzMXhhJaNrQ1pQjtTmL8HIkfoTGE8Edsf10Utoav0pRuAOXRAAcB7xPj3BTRp-BV4GpvjfcS-aXENAbXy-Lo1o4i4rSlcdQ6vdlSzvPDNx41L4CA79zYn3iWt6C50fQ6FoXNAuutM6NGBxY?width=655&height=86&cropmode=none">
		<p>Now let's take a look at this with GDB. We set a breakpoint after the "Hello, world!\n" string has been copied into the str_a buffer and the pointer variable is set to the beginning of it. </p>
		<img src="https://gpbkng.bn1301.livefilestore.com/y3maagGTE0SvTWMrqvI8VythDAwRd6XcLUAwUfqqxF6Yc-VoIABKHZ32eSAbcNa5jdx3CplG8G-GXC8sD0zwR57DI995ApUtXyvqjPqm6qyL5hjvDGPMGbNGN6x4HzoWuem86ub27fbFWo9K9md23vYW5z4N09c0b_lFzcZHbDl1xw?width=653&height=503&cropmode=none">
		<p>When the pointer is examined as a string, it's apparent that the given string is there and is located at memory address 0x6c6c6548 . Remember that the string itself isn't stored in the pointer variable-only the memory address 0x6c6c6548 is stored there. In order to see the actual data stored in the pointer variable, you must use the address-of operator. The address-of operator is a unary operator, which simply means it operates on a single argument. The ampersand (&). </p>

		<img src="https://gpbd7w.bn1301.livefilestore.com/y3m8dijsGn96lwV6gG4Q2xN9CBqL5KRxH3yKmFVYBmkMSvjDQYYDbDHP2ptFknbs3DJbN41IBeuUsZj_ZqJAKDCejxspOJcAL1q2UvLlAXvuXOCIK0dEDeYZoYQfEDNvRXUVu5CYIJ3VU3IjR9sksQsLqF7qxcN8rIzMKJQ3Cf4Jqw?width=652&height=102&cropmode=none">

		<p>We can see that the pointer variable is shown to be located at the address 0x7fffffffde00 in memory, and contains the address 0xffffde10</p>
		<p></p>
		<img src="https://gpb52a.bn1301.livefilestore.com/y3mSnTQSpPpTBYIyQdj9-ke_pWZvF9d7NgPmuKkAYJIx3Q4UBhwjreVZ-La0yeyHG9Ae-FnnzEfcp844rjWWdUJada8cfv_Ascao3eh8aGc_H5s-yzhcSmj5ZdSngj71zPT8Q7fz-lVsesSLCMg6V4gmnqjSFrjCpBo1jFiCSAItYY?width=655&height=391&cropmode=none">

		<p>The first print command shows the value of int_var , and the second shows its address using the address-of operator. The next two print commands show that int_ptr contains the address of int_var , and they also show the address of the int_ptr</p>

		<img src="">

		<p>An additional unary operator called the dereference operator exists for use with pointers. This operator will return the data found in the address the pointer is pointing to, instead of the address itself.</p>

		<img src="https://gpyoew.bn1301.livefilestore.com/y3mNVe6MBiGzCNC8Q38a-eO2chotie-tLFRNygBP3rvmv84BEW7TMtvFKOM1XrXaabdMc_gREcC4xffT9qxvvv_ucrsS75GhkLNW2XMKPQAcc4IsXdi12lgEOl3FKciUwhzUBNlv6lwfjNBLRmmcYbKBMyZZwd0Ou1p2XMfxEy0pSo?width=656&height=120&cropmode=none">


		</article>
		<hr>












































		<article>
	<h1><b>CPU</b></h1>
	
	<p>We are going to look at the intel 8085. The 8085 is a conventional von Neumann design based on the Intel 8080. Is a 8-bit microprocessor and can address, with it's 16 lines, up to 64K memory positions (2^16 = 65536bytes or 64Kb). It has 6200 transistors. Like every processor, it needs a clock or oscillator to synchronize the operations. The 8085 has a clock that generates a digital signal with 3,125 MHz.</p>

	<h2>8085 Terminals </h2>
	<img src="https://7mj97g.bn1301.livefilestore.com/y3mfaWNWjx5GEsN8RXpKYgLSwXPSesoRQiTeZZ0Y8Y0Q92PZd1lUTmjwfi33yJ92hOXUu_O31ItvaM9vw_IzXuUnBXF9pj3ISZ2db93YWiB511P1Ri0EKcszoaRuqEAS0vOLS8zwSJQjPnoBX3lymMhdue7VfZSFz3V98EZa-pqOUg?width=386&height=496&cropmode=none">
	<!--
	<p>A8-A15 Exits of the 8 most significant bits of the address bus</p>
	<p>Ad0-AD7 </p>
	<p>ALE Adress latch enable</p>
	<p>S0-S1 Information about the stat of the data bus. Indicate whether</p>
	<p>RD Read</p>
	<p>WR Write</p>
	<p>READY</p>
	-->

	<p>Each CPU contains basicaly the following blocks:</p>
	<li>Program Counter</li>
	<li>Arithmetic and logic unit</li>
	<li>Instruction Decoder</li>
	<li>General-purpose registers</li>

	<p>The CPU begins by looking at the <b>program counter</b>, and fetching whatever number
is stored in memory at the location specified. It is then passed on to the
<b>instruction decoder</b>
which figures out what the instruction means. This includes what process
needs to take place (addition, subtraction, multiplication, data movement, etc.) and
what memory locations are going to be involved in this process. Computer
instructions usually consist of both the actual instruction and the list of memory
locations that are used to carry it out.
Now the computer uses the
<b>data bus</b>
to fetch the memory locations to be used in
the calculation. The data bus is the connection between the CPU and memory.
In addition to the memory on the outside of the processor, the processor itself has
some special, high-speed memory locations called <b>registers</b>.

<p>The 8085 has several registers: </p>
	<li><b>General-purpose registers</b> - There are 6 general purpose registers in 8085 processor, i.e. B, C, D, E, H and L. Each register can hold 8-bit data.
These registers can work in pair to hold 16-bit data and their pairing combination is like B-C, D-E and H-L.</li>

<p></p><li><b>Program counter</b> - It is a 16-bit register used to store the memory address location of the next instruction to be executed. Microprocessor increments the program whenever an instruction is being executed, so that the program counter points to the memory address of the next instruction that is going to be executed.</li>
<p></p>
<li><b>Stack pointer</b> - It is also a 16-bit register works like stack, which is always incremented/decremented by 2 during push and pop operations.</li>
<p></p>
<li><b>Temporary register</b> - It is an 8-bit register, which holds the temporary data of arithmetic and logical operations.</li>
<p></p>
<li><b>Flag register</b> - It is an 8-bit register having five 1-bit flip-flops, which holds either 0 or 1 depending upon the result stored in the accumulator.
There are 5 flip-flops:
		<p></p>
		<li>Sign (S)</li>
		<li>Zero (Z)</li>
		<li>Auxiliary Carry (AC)</li>
		<li>Parity (P)</li>
		<li>Carry (C)</li>
		</li>
		<p></p>
<li><b>Instruction register and decoder</b> - It is an 8-bit register. When an instruction is fetched from memory then it is stored in the Instruction register. Instruction decoder decodes the information present in the Instruction register.</li>

<p>Now that the CPU has retrieved all of the data it needs, it passes on the data and
the decoded instruction to the arithmetic and logic unit for further processing. <u>Here the instruction is actually executed.</u> After the results of the computation have
been calculated, the results are then placed on the data bus and sent to the
appropriate location in memory or in a register, as specified by the instruction.</p>
<h2>8085 Architecture</h2>
<img src="https://id117w.bn1301.livefilestore.com/y3mb7EiDK4BAo5nXXYseC9z9KtP4Vzrl024jxwIh8pvvNt-SSUm_Te8AEBPVsbcCBt0CRqBdxKYocWb-LtoVZLCRxhkgN_sn2sWgzJEJBzMbyYDORR9oJ_Kp_DNN0fG8lCinbuYIJd4votKac2U5JhYGtkfpjeaqf6gRUguh64DSUs?width=709&height=517&cropmode=none">
<hr></hr>
<h2>Instruction Set</h2>
<img src="https://k5livw.bn1301.livefilestore.com/y3m_-Ul4dX9hZSz9rRC-JSKQfNyVO3ED-VOnshm6BN0AXfIauc5fMbBQIrMKwXb6H9YKMWtnu02LEdZD4F7W2v6LDNg71oM86MN87JNIi5QKR1PQQ9ykuv4ykT92XZFhjmcPaLBHdCR5h7iIw2UiUApAo984tLjsyQU5ORp5LgnMQs?width=989&height=299&cropmode=none" width="100%">
<p>Let's look at instructions. An instruction is a binary pattern designed inside a cpu to perform a specific function. The size of 8085 instructions can be 1 byte, 2 bytes or 3 bytes. The 8085 has 246 instructions, each instruction is represented by an 8-bit binary value. These 8-bits of binary value is called Op-code or instruction Byte.
    <li>The 1-byte instruction has an opcode alone.</li>
    <p></p>

    <li>The 2 bytes instruction has an opcode followed by an eight-bit address or data.</li>
    <p></p>

    <li>The 3 bytes instruction has an opcode followed by 16 bit address or data. While storing the 3 bytes instruction in memory, the sequence of storage is, opcode first followed by low byte of address or data and then high byte of address or data.</li> </p>


<p></p>
</article>
	<br>
	</div>

		<footer class="w3-container w3-theme w3-padding-32" style="padding-left:32px">
	  		<address style="color:white;">Apache/2.4.25 (Unix) Server on raspberrypi at brainpasta.ddns.net Port 80</address>
	  	</footer>   
</div>

<script>
// Open and close the sidenav on medium and small screens
function w3_open() {
    document.getElementById("mySidenav").style.display = "block";
    document.getElementById("myOverlay").style.display = "block";
}
function w3_close() {
    document.getElementById("mySidenav").style.display = "none";
    document.getElementById("myOverlay").style.display = "none";
}

// Change style of top container on scroll
window.onscroll = function() {myFunction()};
function myFunction() {
    if (document.body.scrollTop > 80 || document.documentElement.scrollTop > 80) {
        document.getElementById("myTop").classList.add("w3-card-4", "w3-animate-opacity");
        document.getElementById("myIntro").classList.add("w3-show-inline-block");
    } else {
        document.getElementById("myIntro").classList.remove("w3-show-inline-block");
        document.getElementById("myTop").classList.remove("w3-card-4", "w3-animate-opacity");
    }
}

// Accordions
function myAccordion(id) {
    var x = document.getElementById(id);
    if (x.className.indexOf("w3-show") == -1) {
        x.className += " w3-show";
        x.previousElementSibling.className += " w3-theme";
    } else { 
        x.className = x.className.replace("w3-show", "");
        x.previousElementSibling.className = 
        x.previousElementSibling.className.replace(" w3-theme", "");
    }
}
</script>
     
</body>
</html> 